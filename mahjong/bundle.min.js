(function(){'use strict';let max=Math.max;let random=v=>v?(Math.random()*v)|0:Math.random();function Random(seed){this._seed=seed?seed%2147483647:random(2147483647);if(this._seed<=0)this._seed+=2147483646}
Random.prototype.seed=function(v){if(v)this._seed=v;return this._seed};Random.prototype.next=function(){return this.seed(this._seed*16807%2147483647)};Random.prototype.nextFloat=function(opt_minOrMax,opt_max){return(this.next()-1)/2147483646};const playlog={lines:[],prefix:()=>`${Date.now()}: `,log:(text)=>{if(typeof text!=="string")text=text.toString();text.split('\n').forEach(line=>{playlog.lines.push(`${playlog.prefix()}${line}`)})},flush:()=>{if(config.WRITE_GAME_LOG){let text=playlog.lines.slice().join('\n');playlog.openTab(text)}
playlog.lines=[]},openTab:(text)=>{let a=document.createElement(`a`);a.target=`_blank`;a.href=`data:text/plain;charset=utf-8,${encodeURIComponent(text)}`;a.style.display=`none`;document.body.appendChild(a);a.click();document.body.removeChild(a)}};class LimitHands{hasThirteenOrphans(tiles){let thirteen=[0,8,9,17,18,26,27,28,29,30,31,32,33];thirteen.forEach(t=>{let pos=tiles.indexOf(t);if(pos>-1)tiles.splice(pos,1);});return(tiles.length===1&&thirteen.indexOf(tiles[0])>-1)}
hasNineGates(tiles,lockedSize){if(lockedSize>2)return!1;if(tiles.some(t=>t>=27))return!1;let suit=(tiles[0]/9)|0;if(tiles.some(t=>((t/9)|0)!==suit))return!1;let offset=suit*9;let nine=[0,0,0,1,2,3,4,5,6,7,8,8,8].map(t=>t+offset);nine.forEach(t=>{let pos=tiles.indexOf(t);if(pos>-1)tiles.splice(pos,1);});return(tiles.length===1&&offset<tiles[0]&&tiles[0]<offset+8)}}
class FaakLaakTable{constructor(no_point_score=0,limits){this.no_point_score=no_point_score;this.limits=limits;this.generateConversionTable()}
generateConversionTable(){let faan;this.table={};let limits=this.limits;this.table[0]=this.no_point_score;for(faan=1;faan<limits[0];faan++)this.table[faan]=2**faan;let laak=faan;for(let i=0,e=limits.length-1;i<e;i++){let limit_s=limits[i];let limit_e=limits[i+1];for(let j=limit_s;j<limit_e;j++)this.table[j]=2**laak;laak++}
this.table[limits.slice(-1)]=2**laak}
get(points,selfdraw,limit){let highest_limit=this.limits.slice(-1);if(limit||points>=highest_limit)return this.table[highest_limit];return this.table[points]}}
function hash(set){let s=`${set.type}`;if(set.subtype){s=`${s}s${set.subtype}`}
if(set.type===Constants.PAIR||set.type===Constants.CHOW){s=`${s}t${set.tile}`}
return s}
function unhash$1(print,tile){let re=/(\d+)(s(-?\d+))?(t(\d+))?/;let m=print.match(re);let type=parseInt(m[1]);let subtype=m[3]?parseInt(m[3]):undefined;let required=tile;if(type===Constants.CHOW)tile-=subtype;let obj={required,type,subtype,tile};return obj}
class PatternSet{static from(hash){return new PatternSet(unhash(hash))}
static fromTiles(tiles,locked,concealed){if(typeof tiles[0]!=="number")tiles=tiles.map((t)=>t.getTileFace());let type="";let tile=tiles[0];if(tiles.length===4)type="kong";if(tiles.length===3){if(tiles[1]===tile)type="pung";else type="chow"}
if(tiles.length===2)type="pair";if(tiles.length===1)type="single";return new PatternSet(type,tile,locked,concealed)};constructor(type,tilenumber,locked,concealed){if(tilenumber===undefined){this.content=type}else{this.type=type;this.tilenumber=tilenumber;this.locked=locked;this.concealed=concealed}}
getSetID(){let t=this.type;let asLocked=this.locked&&!this.concealed;if(t===`kong`)return `4k-${this.tilenumber}-${asLocked ? `!` : ``}`;if(t===`pung`)return `3p-${this.tilenumber}-${asLocked ? `!` : ``}`;if(t===`chow`)return `3c-${this.tilenumber}-${asLocked ? `!` : ``}`;if(t===`pair`)return `2p-${this.tilenumber}-${asLocked ? `!` : ``}`;if(t===`single`)return `1s-${this.tilenumber}`;return"0n"}
tiles(){let t=this.type,n=this.tilenumber;if(t==="kong")return[n,n,n,n];if(t==="pung")return[n,n,n];if(t==="chow")return[n,n+1,n+2];if(t==="pair")return[n,n];if(t==="single")return[n];return[]}
size(){let t=this.type;if(t==="kong")return 4;if(t==="pung")return 3;if(t==="chow")return 3;if(t==="pair")return 2;if(t==="single")return 1;return 0}
equals(other){return this.type===other.type&&this.tilenumber===other.tilenumber}
split(...args){return this.toString().split(...args)}
indexOf(...args){return this.toString().indexOf(...args)}
valueOf(){return this.content?this.content.valueOf():this.getSetID()}
toString(){return this.content?this.content.toString():this.getSetID()}}
class Pattern{constructor(tiles=[]){this.keys=[];this.tiles={};tiles.slice().sort((a,b)=>a-b).forEach(v=>{if(this.tiles[v]===undefined){this.tiles[v]=0}
this.tiles[v]++;this.keys.push(v)})}
copy(){let p=new Pattern([],this.canChow);p.keys=this.keys.slice();p.keys.forEach(k=>(p.tiles[k]=this.tiles[k]));return p}
remove(tiles){if(!tiles.forEach)tiles=[tiles];tiles.forEach(t=>{this.tiles[t]--;if(this.tiles[t]===0){delete this.tiles[t];this.keys=Object.keys(this.tiles).sort((a,b)=>a-b)}})}
getSuit(tile){return((tile/9)|0)}
matchSuit(tile,suit){return this.getSuit(tile)===suit}
getChowInformation(tile){let suit=(tile/9)|0;let t1=this.tiles[tile+1];if(t1!==undefined&&!this.matchSuit(tile+1,suit))t1=undefined;let t2=this.tiles[tile+2];if(t2!==undefined&&!this.matchSuit(tile+2,suit))t2=undefined;let t3=this.tiles[tile+3];if(t3!==undefined&&!this.matchSuit(tile+3,suit))t3=undefined;return{t1,t2,t3,suit}}
markNeeded(results,tile,claimtype,subtype=undefined){if(!results[tile])results[tile]=[];let print=hash({type:claimtype,tile,subtype});if(results[tile].indexOf(print)===-1)results[tile].push(print);}
markWin(results,tile,subtype){this.markNeeded(results,tile,Constants.WIN,subtype)}
recurse(seen,chain,to_remove,results,singles,pairs,sets){let downstream=this.copy();downstream.remove(to_remove);if(downstream.keys.length>0){return downstream.runExpand(seen,chain,results,singles,pairs,sets)}
if(sets.length===4&&pairs.length===1&&singles.length===0){if(!results.win)results.win=[];results.win.push({pair:pairs,sets})}else if(sets.length===4&&pairs.length===0&&singles.length===1){this.markWin(results,singles[0],Constants.PAIR)}else if(sets.length===3&&pairs.length===2){this.markWin(results,pairs[0],Constants.PUNG);this.markWin(results,pairs[1],Constants.PUNG)}else if(sets.length===3&&pairs.length===1&&singles.length===2){if(singles[1]<27&&singles[0]+1===singles[1]){let t1=singles[0]-1,s1=this.getSuit(t1),b0=singles[0],s2=this.getSuit(b0),b1=singles[1],s3=this.getSuit(b1),t2=singles[1]+1,s4=this.getSuit(t2);if(s1===s2&&s1===s3)this.markWin(results,t1,Constants.CHOW1);if(s4===s2&&s4===s3)this.markWin(results,t2,Constants.CHOW3);}else if(singles[1]<27&&singles[1]===singles[0]+2){let middle=singles[0]+1;let s1=this.getSuit(singles[0]);let s2=this.getSuit(middle);let s3=this.getSuit(singles[1]);if(s1===s3&&s1===s2)this.markWin(results,middle,Constants.CHOW2);}}}
runExpand(seen=[],paths=[],results=[],singles=[],pairs=[],sets=[]){if(!this.keys.length){if(sets.length===4&&pairs.length===1&&singles.length===0){if(!results.win)results.win=[];results.win.push({pair:pairs,sets})}
return{results,paths}}
seen=seen.slice();let tile=(this.keys[0]|0);seen.push(tile);let count=this.tiles[tile];let head=[];let toRemove=[];if(count>3){head=[new PatternSet(`kong`,tile)];paths.push(head);toRemove=[tile,tile,tile,tile];this.recurse(seen,head,toRemove,results,singles,pairs,sets.concat(head))}
if(count>2){head=[new PatternSet(`pung`,tile)];paths.push(head);toRemove=[tile,tile,tile];this.markNeeded(results,tile,Constants.KONG);this.recurse(seen,head,toRemove,results,singles,pairs,sets.concat(head))}
if(count>1){head=[new PatternSet(`pair`,tile)];paths.push(head);toRemove=[tile,tile];this.markNeeded(results,tile,Constants.PUNG);this.recurse(seen,head,toRemove,results,singles,pairs.concat([tile]),sets)}
this.recurse(seen,paths,[tile],results,singles.concat([tile]),pairs,sets);if(tile>26)return{results,paths};let{t1,t2,t3}=this.getChowInformation(tile);if(t1||t2){let suit=this.getSuit(tile);if(t1&&t2){head=[new PatternSet(`chow`,tile)];paths.push(head);toRemove=[tile,tile+1,tile+2];if(t3){this.markNeeded(results,tile+1,Constants.CHOW1);this.markNeeded(results,tile+2,Constants.CHOW3)}
if(seen.indexOf(tile-1)===-1){if(this.matchSuit(tile-1,suit))this.markNeeded(results,tile-1,Constants.CHOW1);}
this.recurse(seen,head,toRemove,results,singles,pairs,sets.concat(head))}else if(t1){if(this.matchSuit(tile+2,suit))this.markNeeded(results,tile+2,Constants.CHOW3);if(seen.indexOf(tile-1)===-1){if(this.matchSuit(tile-1,suit))this.markNeeded(results,tile-1,Constants.CHOW1);}
this.recurse(seen,paths,[tile,tile+1],results,singles,pairs,sets)}else{this.markNeeded(results,tile+1,Constants.CHOW2);this.recurse(seen,paths,[tile,tile+2],results,singles,pairs,sets)}}
return{results,paths}}
expand(pair=[],set=[]){return this.copy().runExpand([],[],[],[],pair,set)}}
function tilesNeeded(tiles,locked=[],excludeTile=null){if(excludeTile!==null){let idx=tiles.findIndex(t=>t===excludeTile);if(idx>=0)tiles.splice(idx,1);}
let p=new Pattern(tiles);locked=convertToPatternSets(locked);let pair=[];locked.some((set,pos)=>{if(set.type==='pair'){pair.push(set);return locked.splice(pos,1)}});let{results,paths}=p.expand(pair.map(s=>s.tilenumber),locked);let winpaths=(results.win||[]).map(result=>{let p=pair[0];let rpair=new PatternSet('pair',result.pair[0]);return[(p&&p.equals(rpair))?p:rpair,...result.sets]});let winner=(winpaths.length>0);delete results.win;let lookout=results;let waiting=!winner&&lookout.some(list=>list.some(type=>type.indexOf('32')===0));paths=paths.map(path=>unroll(path));let composed=getUniqueCompositions(paths,);let to_complete=getStillNeeded(locked,composed);return{lookout,waiting,composed,to_complete,winner,winpaths}}
function convertToPatternSets(locked){return locked.map(set=>{let numbered=set.map(t=>t.getTileFace?t.getTileFace():t).sort();return PatternSet.fromTiles(numbered,!0,set.concealed)}).filter(v=>v)}
function getUniqueCompositions(paths){let composed=[];paths.forEach(path=>path.forEach(part=>{if(composed.some(e=>e===part))return;composed.push(part)}));composed.sort((a,b)=>a.length-b.length);let filtered=[];for(let i=0,e=composed.length;i<e;i++){let allFound=!1;let list=composed[i];for(let j=i+1;j<e;j++){let other=composed[j];allFound=list.every(part=>other.find(e=>e.equals(part)));if(allFound)break}
if(!allFound)filtered.push(list);}
return filtered}
function getStillNeeded(locked,composed){let pcount=1,scount=4;if(locked.length>0){locked.forEach(set=>{if(set.size()===2)pcount--;else scount--})}
let to_complete=[];composed.forEach((composition,pos)=>{let p=pcount,s=scount,list=[];composition.forEach(set=>{if(set.size()===2)p--;else s--});if(p>0)list.push(Constants.PAIR);while(s-->0)list.push(Constants.SET);to_complete[pos]=list});return to_complete}
class Ruleset{getWindTile(wind){return 27+wind}
ownFlower(tile,windTile){return tile-34===windTile-27}
ownSeason(tile,windTile){return tile-38===windTile-27}
allFlowers(bonus){return[34,35,36,37].every(t=>bonus.indexOf(t)>-1)}
allSeasons(bonus){return[38,39,40,41].every(t=>bonus.indexOf(t)>-1)}
constructor(scoretype,player_start_score,limit,points_for_winning,no_point_score,losers_settle_scores,east_doubles_up,selfdraw_pays_double,discard_pays_double,reverse_wind_direction,pass_on_east_win,){this.scoretype=scoretype;this.limits=new LimitHands();this.player_start_score=player_start_score;this.limit=limit;this.points_for_winning=points_for_winning;this.no_point_score=no_point_score;this.losers_settle_scores=losers_settle_scores;this.east_doubles_up=east_doubles_up;this.selfdraw_pays_double=selfdraw_pays_double;this.discard_pays_double=discard_pays_double;this.reverse_wind_direction=reverse_wind_direction;this.pass_on_east_win=pass_on_east_win;if(scoretype===Ruleset.FAAN_LAAK){this.limit=limit[0];this.faan_laak_limits=limit;this.setupFaanLaakTable(no_point_score,limit)}}
setupFaanLaakTable(no_point_score,limits){this.faan_laak_table=new FaakLaakTable(no_point_score,limits)}
getPointsDoubleLimit(){return this.limit}
getFaanLaakLimit(selfdraw){return this.faan_laak_table.get(0,selfdraw,!0)}
convertFaan(points,selfdraw,limit){return this.faan_laak_table.get(points,selfdraw,limit)}
convertPoints(points,doubles){if(!points&&this.no_point_score)points=this.no_point_score;return points*(2**doubles)}
getLimitPoints(selfdraw){if(this.scoretype===Ruleset.POINTS_DOUBLES)return this.getPointsDoubleLimit();if(this.scoretype===Ruleset.FAAN_LAAK)return this.getFaanLaakLimit(selfdraw);console.error('unknown scoring type');return 0}
checkForLimit(allTiles,lockedSize){if(allTiles.length<14)return;const tiles=()=>allTiles.slice().map(t=>t|0).sort();if(this.limits.hasThirteenOrphans(tiles()))return `Thirteen orphans`;if(this.limits.hasNineGates(tiles(),lockedSize))return `Nine gates`}
generateLimitObject(limit,selfdraw){return{limit:limit,log:[`Limit hand: ${limit}`],score:0,doubles:0,total:this.getLimitPoints(selfdraw)}}
settleScores(scores,winningplayer,eastplayer,discardpid){console.debug(`%cSettling payment`,`color: red`);let adjustments=[0,0,0,0];let eastWinFactor=(winningplayer===eastplayer)?2:1;let wscore=scores[winningplayer].total;let selfdraw=(discardpid===!1);console.debug(`winning score: ${wscore}, double east? ${this.east_doubles_up}`);for(let i=0;i<scores.length;i++){if(i===winningplayer)continue;if(i!==winningplayer){let difference=wscore;if(this.east_doubles_up){let paysAsEast=(i===eastplayer)?2:1;difference*=Math.max(eastWinFactor,paysAsEast)}
if((this.discard_pays_double&&i===discardpid)||(this.selfdraw_pays_double&&selfdraw)){difference*=2}
adjustments[winningplayer]+=difference;console.debug(`${winningplayer} gets ${difference} from ${i}`);adjustments[i]-=difference;console.debug(`${i} pays ${difference} to ${winningplayer}`)}
if(!this.losers_settle_scores)continue;for(let j=i+1;j<scores.length;j++){if(j===winningplayer)continue;let difference=(scores[i].total-scores[j].total);if(this.east_doubles_up){let paysAsEast=(i===eastplayer)?2:1;difference*=paysAsEast}
console.debug(`${i} gets ${difference} from ${j}`);adjustments[i]+=difference;console.debug(`${j} pays ${difference} to ${i}`);adjustments[j]-=difference}}
if(this.east_doubles_up){if(winningplayer===eastplayer)scores[eastplayer].log.push(`Player won as East`);else scores[eastplayer].log.push(`Player lost as East`)}
return adjustments}
getPairValue(){return!1}
getChowValue(){return!1}
getPungValue(){return!1}
getKongValue(){return!1}
_tile_score(set,windTile,windOfTheRoundTile){let locked=set.locked;let concealed=set.concealed;let tiles=set.tiles();let tile=tiles[0];let names=config.TILE_NAMES;if(tiles.length===2)return this.getPairValue(tile,locked,concealed,names,windTile,windOfTheRoundTile);if(tiles.length===3){if(tile!==tiles[1])return this.getChowValue(tile,locked,concealed,names,windTile,windOfTheRoundTile);else return this.getPungValue(tile,locked,concealed,names,windTile,windOfTheRoundTile)}
if(tiles.length===4)return this.getKongValue(tile,locked,concealed,names,windTile,windOfTheRoundTile);}
checkBonusTilePoints(bonus,windTile,names,result){}
checkHandPatterns(scorePattern,windTile,windOfTheRoundTile,tilesLeft,result){}
checkWinnerHandPatterns(scorePattern,winset,selfdraw,windTile,windOfTheRoundTile,tilesLeft,scoreObject){}
aggregateScorePattern(scorePattern,windTile,windOfTheRoundTile){return scorePattern.map(set=>this._tile_score(set,windTile,windOfTheRoundTile)).filter(v=>v).reduce((t,v)=>{t.score+=v.score;t.doubles+=(v.doubles||0);t.log=t.log.concat(v.log);return t},{score:0,doubles:0,log:[]})}
getTileScore(scorePattern,windTile,windOfTheRoundTile,bonus,winset,winner=!1,selfdraw=!1,selftile=!1,robbed=!1,tilesLeft){let names=config.TILE_NAMES;let result=this.aggregateScorePattern(scorePattern,windTile,windOfTheRoundTile);result.wind=windTile;result.wotr=windOfTheRoundTile;this.checkBonusTilePoints(bonus,windTile,names,result);this.checkHandPatterns(scorePattern,windTile,windOfTheRoundTile,tilesLeft,result);if(winner){if(this.points_for_winning>0){result.score+=this.points_for_winning;result.log.push(`${this.points_for_winning} for winning`)}
this.checkWinnerHandPatterns(scorePattern,winset,selfdraw,selftile,robbed,windTile,windOfTheRoundTile,tilesLeft,result)}
if(result.limit){result.score=this.limit;result.doubles=0;result.total=this.limit;result.log.push(`Limit hand: ${result.limit}`)}else{result.total=0;if(this.scoretype===Ruleset.POINTS_DOUBLES){result.total=this.convertPoints(result.score,result.doubles);if(result.total>this.limit){result.log.push(`Score limited from ${result.total} to ${this.limit}`);result.total=this.limit}}
if(this.scoretype===Ruleset.FAAN_LAAK){result.total=this.convertFaan(result.score,selfdraw)}}
return result}
getState(scorePattern,winset,selfdraw,selftile,robbed,windTile,windOfTheRoundTile,tilesLeft){let state={chowhand:!0,punghand:!0,onesuit:!0,honours:!1,allhonours:!0,terminals:!0,allterminals:!0,outonPair:!0,pairTile:-1,majorPair:!1,dragonPair:!1,windPair:!1,ownWindPair:!1,wotrPair:!1,ownWindPung:!1,wotrPung:!1,ownWindKong:!1,wotrKong:!1,chowCount:0,windPungCount:0,windKongCount:0,dragonPungCount:0,dragonKongCount:0,concealedCount:0,kongCount:0,suit:!1,selfdraw:selfdraw,robbed:robbed,lastTile:(tilesLeft<=0)};state.allGreen=scorePattern.every(set=>set.tiles().every(t=>[1,2,3,5,7,31].indexOf(t)>-1));let tiles,tile,tilesuit;scorePattern.forEach(set=>{if(!set.locked||set.concealed)state.concealedCount++;tiles=set.tiles();tile=tiles[0];tilesuit=(tile/9)|0;if(tile<27){if(state.suit===!1)state.suit=tilesuit;else if(state.suit!==tilesuit)state.onesuit=!1;if(tiles.some(t=>(t%9)!==0&&(t%9)!==8)){state.terminals=!1;state.allterminals=!1}
state.allhonours=!1}else{state.honours=!0;state.allterminals=!1}
if(tiles.length===2){if(winset){let wintiles=winset.tiles();state.outonPair=(wintiles.length===2&&wintiles[0]===tiles[0]);state.pairTile=wintiles[0]}else if(!winset&&selfdraw&&tiles[0]===selftile){state.outonPair=!0;state.pairTile=selftile}else{state.outonPair=!1;if(tile>26&&tile<31){state.windPair=!0;state.majorPair=!0}
if(tile>30){state.dragonPair=!0;state.majorPair=!0}
if(tile===windTile){state.ownWindPair=!0;state.majorPair=!0}
if(tile===windOfTheRoundTile){state.wotrPair=!0;state.majorPair=!0}}}
if(tiles.length===3){if(tile===tiles[1]){if(tile>26&&tile<31){state.windPungCount++;if(tile===windTile)state.ownWindPung=!0;if(tile===windOfTheRoundTile)state.wotrPung=!0}
if(tile>30)state.dragonPungCount++;state.chowhand=!1}else{state.chowCount++;state.punghand=!1}}
if(tiles.length===4){state.kongCount++;if(tile>26&&tile<31){state.windKongCount++;if(tile===windTile)state.ownWindKong=!0;if(tile===windOfTheRoundTile)state.wotrKong=!0}
if(tile>30)state.dragonKongCount++;state.chowhand=!1}});return state}
scoreTiles(disclosure,id,windOfTheRound,tilesLeft){console.debug("SCORE TILES",id,disclosure,windOfTheRound,tilesLeft);let winner=disclosure.winner;let selfdraw=disclosure.selfdraw;let selftile=disclosure.selftile?disclosure.selftile.getTileFace():!1;let robbed=disclosure.robbed;let tiles=disclosure.concealed;let locked=disclosure.locked;let bonus=disclosure.bonus;let winset=!1;let windTile=this.getWindTile(disclosure.wind);let windOfTheRoundTile=this.getWindTile(windOfTheRound);let allTiles=tiles.slice();locked=locked.map(set=>{if(set.length===4){let ccount=set.reduce((tally,t)=>tally+(t.isConcealed()?1:0),0);if(ccount>=3)set.concealed=`${ccount}`}
return set});let tileInformation=tilesNeeded(tiles,locked);let openCompositions=tileInformation.composed;locked=locked.map(set=>{let newset=PatternSet.fromTiles(set,!0,set.concealed);allTiles.push(...set);if(!!set[0].isWinningTile())winset=newset;return newset});if(winner){let limit=this.checkForLimit(allTiles,locked.reduce((t,s)=>t+s.length,0));if(limit){config.log('limit hand');return this.generateLimitObject(limit,selfdraw)}
openCompositions=tileInformation.winpaths}else{if(!this.losers_settle_scores){config.log('losers do not require score computation');return{score:0,doubles:0,log:[],total:0}}
if(openCompositions.length===0)openCompositions.push([]);}
let possibleScores=openCompositions.map(chain=>{return this.getTileScore(chain.concat(winner?[]:locked),windTile,windOfTheRoundTile,bonus,winset,winner,selfdraw,selftile,robbed,tilesLeft)});config.log('possible scores:',possibleScores);let finalScore=possibleScores.sort((a,b)=>{a=a.total;b=b.total;return a-b}).slice(-1)[0];config.log('final score:',finalScore);if(!finalScore){disclosure.locked=disclosure.locked.map(set=>set.map(tile=>tile.values?tile.values.tile:tile));throw new Error("no score could be computed")}
return finalScore}
_determineImprovement(concealed,locked,composed,to_complete,tiletracker){return[]}
determineImprovement(player,tilesLeft,winner=!1){let concealed=player.getTileFaces();let locked=player.locked;let data=this.scoreTiles({winner,wind:player.wind,concealed,locked,bonus:player.bonus},player.id,player.windOfTheRound,tilesLeft);let{composed,to_complete}=player.tilesNeeded();data.improvement=this._determineImprovement(concealed,locked,composed,to_complete,player.tracker);return data}}
Ruleset.FAAN_LAAK=Symbol();Ruleset.POINTS_DOUBLES=Symbol();(()=>{let rulesets={};Ruleset.register=function(RulesetClass){let naturalName=RulesetClass.name.replace(/([a-z])([A-Z])/g,(_,b,c)=>`${b} ${c}`);rulesets[naturalName]=new RulesetClass()};Ruleset.getRuleset=name=>rulesets[name];Ruleset.getRulesetNames=()=>Object.keys(rulesets)})();class Cantonese extends Ruleset{constructor(){super(Ruleset.FAAN_LAAK,500,[5,7,10],0,0.5,!1,!1,!0,!0,!0,!0)}
getPungValue(tile,locked,concealed,names,windTile,windOfTheRoundTile){let prefix=(locked&&!concealed)?"":"concealed ";if(tile>26){if(tile>30){return{score:1,log:[`1 faan for ${prefix}pung of dragons (${names[tile]})`]}}
let scoreObject={score:0,log:[]};if(tile===windTile){scoreObject.score+=1;scoreObject.log.push(`1 faan for ${prefix}pung of player's own wind (${names[tile]})`)}
if(tile===windOfTheRoundTile){scoreObject.score+=1;scoreObject.log.push(`1 faan for ${prefix}pung of wind of the round (${names[tile]})`)}
return scoreObject}}
getKongValue(tile,locked,concealed,names,windTile,windOfTheRoundTile){let prefix=(locked&&!concealed)?"":"concealed ";if(tile>26){if(tile>30){return{score:1,log:[`1 faan for ${prefix}kong of dragons (${names[tile]})`]}}
let scoreObject={score:0,log:[]};if(tile===windTile){scoreObject.score+=1;scoreObject.log.push(`1 faan for ${prefix}kong of player's own wind (${names[tile]})`)}
if(tile===windOfTheRoundTile){scoreObject.score+=1;scoreObject.log.push(`1 faan for ${prefix}kong of wind of the round (${names[tile]})`)}
return scoreObject}}
checkHandPatterns(scorePattern,windTile,windOfTheRoundTile,tilesLeft,scoreObject){let r,g,w;scorePattern.forEach(set=>{let tile=set[0];if(tile===31)g=set.length;if(tile===32)r=set.length;if(tile===33)w=set.length});if(r+g+w>=8&&(r===2||g===2||w===2)){scoreObject.score+=4;scoreObject.log.push(`4 faan for little three dragons`)}}
checkWinnerHandPatterns(scorePattern,winset,selfdraw,selftile,robbed,windTile,windOfTheRoundTile,tilesLeft,scoreObject){let names=config.TILE_NAMES;let suits=config.SUIT_NAMES;let state=this.getState(scorePattern,winset,selfdraw,selftile,robbed,windTile,windOfTheRoundTile,tilesLeft);if(state.selfdraw){scoreObject.score+=1;scoreObject.log.push(`1 faan for self-drawn win (${names[selftile]})`)}
if(state.robbed){scoreObject.score+=1;scoreObject.log.push(`1 faan for robbing a kong (${names[winset[0]]})`)}
if(state.chowhand&&!state.majorPair){scoreObject.score+=1;scoreObject.log.push(`1 faan for chow hand`)}
if(state.onesuit){if(state.honours){scoreObject.score+=1;scoreObject.log.push(`1 faan for one suit (${suits[state.suit]}) and honours hand`)}else{scoreObject.score+=5;scoreObject.log.push(`5 faan for clean one suit hand (${suits[state.suit]})`)}}
if(state.allterminals){scoreObject.limit=`all terminals hand`}
if(state.allhonours){scoreObject.limit=`all honours hand`}
if(state.punghand){scoreObject.score+=3;scoreObject.log.push(`3 faan for all pung hand`)}
if(state.dragonPungCount+state.dragonKongCount===3){scoreObject.limit=`Three great scholars (pung or kong of each dragon)`}
if(state.windPungCount+state.windKongCount===3&&state.windPair){scoreObject.limit=`Little four winds (pung or kong of three wind, pair of last wind)`}
if(state.windPungCount+state.windKongCount===4){scoreObject.limit=`Big four winds (pung or kong of each wind)`}
if(state.concealedCount===5){scoreObject.score+=1;scoreObject.log.push(`1 faan for fully concealed hand`)}
if(scoreObject.score===0){scoreObject.log.push(`${this.no_point_score} for no-point hand`)}}
checkBonusTilePoints(bonus,windTile,names,result){let hasOwnFlower=!1;let hasOwnSeason=!1;bonus.forEach(tile=>{if(this.ownFlower(tile,windTile))hasOwnFlower=!0;if(this.ownSeason(tile,windTile))hasOwnSeason=!0});if(bonus.length===0){result.score+=1;result.log.push(`1 faan for no flowers or seasons`)}
if(hasOwnFlower){result.score+=1;result.log.push(`1 faan for own flower and season`)}
if(hasOwnSeason){result.score+=1;result.log.push(`1 faan for own flower and season`)}
if(this.allFlowers(bonus)){result.score+=1;result.log.push(`1 faan for having all flowers`)}
if(this.allSeasons(bonus)){result.score+=1;result.log.push(`1 faan for having all seasons`)}}}
Ruleset.register(Cantonese);class ChineseClassical extends Ruleset{constructor(){super(Ruleset.POINTS_DOUBLES,2000,1000,10,!1,!0,!0,!1,!1,!0,!1)}
getPairValue(tile,locked,concealed,names,windTile,windOfTheRoundTile){if(tile>30)return{score:2,log:[`2 for pair of dragons (${names[tile]})`]};if(tile===windTile)return{score:2,log:[`2 for pair of own wind (${names[tile]})`]};if(tile===windOfTheRoundTile)return{score:2,log:[`2 for pair of wind of the round (${names[tile]})`]}}
getPungValue(tile,locked,concealed,names,windTile,windOfTheRoundTile){let prefix=(locked&&!concealed)?"":"concealed ";let value=0;if(tile>30){value=locked?4:8;return{score:value,doubles:1,log:[`${value} for ${prefix}pung of dragons (${names[tile]})`,`1 double for pung of dragons (${names[tile]})`]}}
if(tile>26){value=locked?4:8;let scoreObject={score:value,doubles:0,log:[`${value} for ${prefix}pung of winds (${names[tile]})`]};if(tile===windTile){scoreObject.doubles+=1;scoreObject.log.push(`1 double for pung of player's own wind (${names[tile]})`)}
if(tile===windOfTheRoundTile){scoreObject.doubles+=1;scoreObject.log.push(`1 double for pung of wind of the round (${names[tile]})`)}
return scoreObject}
if(tile<27){let type;if(tile%9===0||tile%9===8){type=`terminals`;value=locked?4:8}else{type=`simple`;value=locked?2:4}
return{score:value,log:[`${value} for ${prefix}pung of ${type} (${names[tile]})`]}}}
getKongValue(tile,locked,concealed,names,windTile,windOfTheRoundTile){let value=0;let prefix=``;let ccount=concealed;if(!ccount)prefix=`melded `;else if(ccount===3)prefix=`claimed `;else if(ccount===4)prefix=`concealed `;if(tile>30){value=(locked||ccount===3)?16:32;return{score:value,doubles:1,log:[`${value} for ${prefix}kong of dragons (${names[tile]})`,`1 double for kong of dragons (${names[tile]})`]}}
if(tile>26){value=(locked||ccount===3)?16:32;let scoreObject={score:value,doubles:0,log:[`${value} for ${prefix}kong of winds (${names[tile]})`]};if(tile===windTile){scoreObject.doubles+=1;scoreObject.log.push(`1 double for kong of player's own wind (${names[tile]})`)}
if(tile===windOfTheRoundTile){scoreObject.doubles+=1;scoreObject.log.push(`1 double for kong of wind of the round (${names[tile]})`)}
return scoreObject}
if(tile<27){let type;if(tile%9===0||tile%9===8){type=`terminals`;value=(locked||ccount===3)?16:32}else{type=`simple`;value=(locked||ccount===3)?8:16}
return{score:value,log:[`${value} for ${prefix}kong of ${type} (${names[tile]})`]}}}
checkHandPatterns(scorePattern,windTile,windOfTheRoundTile,tilesLeft,scoreObject){let r,g,w;scorePattern.forEach(set=>{let tile=set[0];if(tile===31)g=set.length;if(tile===32)r=set.length;if(tile===33)w=set.length});if(r+g+w>=8&&(r===2||g===2||w===2)){scoreObject.doubles+=1;scoreObject.log.push(`1 double for little three dragons`)}}
checkWinnerHandPatterns(scorePattern,winset,selfdraw,selftile,robbed,windTile,windOfTheRoundTile,tilesLeft,scoreObject){let names=config.TILE_NAMES;let suits=config.SUIT_NAMES;let state=this.getState(scorePattern,winset,selfdraw,selftile,robbed,windTile,windOfTheRoundTile,tilesLeft);if(state.selfdraw){scoreObject.score+=2;scoreObject.log.push(`2 for self-drawn win (${names[selftile]})`)}
if(state.robbed){scoreObject.doubles+=1;scoreObject.log.push(`1 double for robbing a kong (${names[winset[0]]})`)}
if(state.outonPair){scoreObject.score+=2;scoreObject.log.push(`2 for winning on a pair (${names[state.pairTile]})`)}
if(state.outonPair&&state.majorPair){scoreObject.score+=2;scoreObject.log.push(`2 for winning on a major pair`)}
if(state.chowhand&&!state.majorPair){scoreObject.doubles+=1;scoreObject.log.push(`1 double for chow hand`)}
if(state.onesuit){if(state.honours){scoreObject.doubles+=1;scoreObject.log.push(`1 double for one suit (${suits[state.suit]}) and honours hand`)}else{scoreObject.doubles+=3;scoreObject.log.push(`3 doubles for clean one suit hand (${suits[state.suit]})`)}}
if(state.allterminals){scoreObject.limit=`all terminals hand`}
if(state.allhonours){scoreObject.limit=`all honours hand`}
if(state.terminals&&state.honours){scoreObject.doubles+=1;scoreObject.log.push(`1 double for terminals an honours hand`)}
if(state.punghand){scoreObject.doubles+=1;scoreObject.log.push(`1 double for all pung hand`)}
if(state.kongCount===4){scoreObject.limit=`All kong hand`}
if(state.dragonPungCount+state.dragonKongCount===3){scoreObject.limit=`Three great scholars (pung or kong of each dragon)`}
if(state.windPungCount+state.windKongCount===3&&state.windPair){scoreObject.limit=`Little four winds (pung or kong of three wind, pair of last wind)`}
if(state.windPungCount+state.windKongCount===4){scoreObject.limit=`Big four winds (pung or kong of each wind)`}
if(state.concealedCount===5){scoreObject.doubles+=1;scoreObject.log.push(`1 double for fully concealed hand`)}
if(state.concealedCount===5&&state.punghand){scoreObject.limit=`Fully concealed pung hand`}
if(state.lastTile){scoreObject.doubles+=1;if(selfdraw){scoreObject.log.push(`1 double for winning with the last available wall tile`)}else{scoreObject.log.push(`1 double for winning with the last discard`)}}
if(state.allGreen){scoreObject.limit=`"All Green" (bamboos 2, 3, 4, 6, 8 and/or green dragons)`}}
checkBonusTilePoints(bonus,windTile,names,result){let hasOwnFlower=!1;let hasOwnSeason=!1;bonus.forEach(tile=>{result.score+=4;result.log.push(`4 for bonus tile (${names[tile]})`);if(this.ownFlower(tile,windTile))hasOwnFlower=!0;if(this.ownSeason(tile,windTile))hasOwnSeason=!0});if(hasOwnFlower&&hasOwnSeason){result.doubles+=1;result.log.push(`1 double for own flower and season`)}
if(this.allFlowers(bonus)){result.doubles+=2;result.log.push(`1 double for having all flowers`)}
if(this.allSeasons(bonus)){result.doubles+=2;result.log.push(`1 double for having all seasons`)}}}
Ruleset.register(ChineseClassical);const noop=()=>{};const __console_debug=console.debug.bind(console);const updateCurrentConfig=()=>{const fromStorage=JSON.parse(localStorage.getItem("mahjongConfig")||"{}");for(var key in DEFAULT_CONFIG){if(!(key in fromStorage)){fromStorage[key]=DEFAULT_CONFIG[key]}}
globalThis.currentConfig=fromStorage;for(const[key,value]of Object.entries(globalThis.currentConfig)){if(value==="true")globalThis.currentConfig[key]=!0;if(value==="false")globalThis.currentConfig[key]=!1;if(value==parseFloat(value))globalThis.currentConfig[key]=parseFloat(value);}
for(var key in globalThis.currentConfig){config[key]=globalThis.currentConfig[key]}
var sidebar=document.querySelector(".sidebar");if(sidebar){sidebar.classList.toggle("hidden",!config.SHOW_TILE_TRACKER)}}
const DEFAULT_CONFIG={DEBUG:!1,USE_SOUND:!0,SEED:0,RULES:`Chinese Classical`,PLAY_IMMEDIATELY:!1,PAUSE_ON_BLUR:!0,FORCE_DRAW:!1,FORCE_OPEN_BOT_PLAY:!1,SHOW_CLAIM_SUGGESTION:!0,AUTO_SKIP_DISCARDS:!0,SHOW_BOT_SUGGESTION:!0,SHOW_TILE_TRACKER:!0,BOT_CHICKEN_THRESHOLD:0.0008,CLAIM_INTERVAL:5000,PLAY_INTERVAL:100,HAND_INTERVAL:3000,BOT_DELAY_BEFORE_DISCARD_ENDS:300,BOT_PLAY_DELAY:50,WALL_HACK:"",WRITE_GAME_LOG:!1,};globalThis.currentConfig={};const CLAIM$1={IGNORE:0,PAIR:1,CHOW:2,CHOW1:4,CHOW2:5,CHOW3:6,PUNG:8,KONG:16,SET:30,WIN:32,};const Constants={PAIR:CLAIM$1.PAIR,CHOW:CLAIM$1.CHOW,CHOW1:CLAIM$1.CHOW1,CHOW2:CLAIM$1.CHOW2,CHOW3:CLAIM$1.CHOW3,PUNG:CLAIM$1.PUNG,KONG:CLAIM$1.KONG,SET:CLAIM$1.SET,WIN:CLAIM$1.WIN,};const TILE_NAMES={0:"bamboo 1",1:"bamboo 2",2:"bamboo 3",3:"bamboo 4",4:"bamboo 5",5:"bamboo 6",6:"bamboo 7",7:"bamboo 8",8:"bamboo 9",9:"characters 1",10:"characters 2",11:"characters 3",12:"characters 4",13:"characters 5",14:"characters 6",15:"characters 7",16:"characters 8",17:"characters 9",18:"dots 1",19:"dots 2",20:"dots 3",21:"dots 4",22:"dots 5",23:"dots 6",24:"dots 7",25:"dots 8",26:"dots 9",27:"east",28:"south",29:"west",30:"north",31:"green dragon",32:"red dragon",33:"white dragon",34:"flower 1",35:"flower 2",36:"flower 3",37:"flower 4",38:"season 1",39:"season 2",40:"season 3",41:"season 4",};const TILE_GLYPHS={0:"b1",1:"b2",2:"b3",3:"b4",4:"b5",5:"b6",6:"b7",7:"b8",8:"b9",9:"c1",10:"c2",11:"c3",12:"c4",13:"c5",14:"c6",15:"c7",16:"c8",17:"c9",18:"d1",19:"d2",20:"d3",21:"d4",22:"d5",23:"d6",24:"d7",25:"d8",26:"d9",27:"E",28:"S",29:"W",30:"N",31:"F",32:"C",33:"P",34:"f1",35:"f2",36:"f3",37:"f4",38:"s1",39:"s2",40:"s3",41:"s4",};const SUIT_NAMES={0:"bamboo",1:"characters",2:"dots",3:"winds",4:"dragons",5:"bonus",};const config=Object.assign({set:(opt)=>{Object.keys(opt).forEach((key)=>{let value=opt[key];if(typeof config[key]!=="undefined"){config[key]=value;if(key===`DEBUG`){if(value){console.debug=__console_debug}else{console.debug=noop}}}})},DEFAULT_CONFIG,PRNG:new Random(globalThis.currentConfig.SEED),DEBUG:globalThis.currentConfig.DEBUG,log:noop,flushLog:noop,START_OVERRIDE_SEED:0,START_ON_HAND:0,PAUSE_ON_HAND:0,START_ON_DRAWS:0,PAUSE_ON_DRAW:0,PAUSE_ON_PLAY:0,BOT_PLAY:!1,ARTIFICIAL_BOT_DELAY:300,LOSERS_SETTLE_SCORES:!0,CLAIM:CLAIM$1,Constants,TILE_NAMES,TILE_GLYPHS,SUIT_NAMES,convertSubtypeToClaim:(diff)=>{if(diff===-1)return CLAIM$1.CHOW3;if(diff===1)return CLAIM$1.CHOW2;if(diff===2)return CLAIM$1.CHOW1;return diff},},globalThis.currentConfig);updateCurrentConfig();config.set({DEBUG:globalThis.currentConfig.DEBUG});config.log=playlog.log;config.flushLog=playlog.flush;class GameTile extends HTMLElement{constructor(tile,values=null){super();if(values)tile=values.tile
else tile=tile??this.getAttribute(`tile`)??-1;this.values=values?values:{tile};this.setAttribute(`tile`,this.values.tile);this.setAttribute(`title`,TILE_NAMES[tile]);this.setAttribute(`alt`,TILE_NAMES[tile])}
static get observedAttributes(){return[`bonus`,`tile`,`locked`,`locknum`,`hidden`,`concealed`,`supplement`,]}
attributeChangedCallback(attr,oldVal,newVal){if(oldVal===newVal)return;this.onChange(attr,newVal)}
onChange(attributeName,attributeValue){let asBool=new Boolean(attributeValue).toString();if(attributeValue==asBool){return(this.values[attributeName]=asBool)}
let asInt=parseInt(attributeValue);if(attributeValue==asInt){return(this.values[attributeName]=asInt)}
let asFloat=parseFloat(attributeValue);if(attributeValue==asFloat){return(this.values[attributeName]=asFloat)}
this.values[attributeName]=attributeValue}
mark(...labels){labels.forEach((label)=>this.classList.add(label))}
unmark(...labels){labels.forEach((label)=>this.classList.remove(label))}
getFrom(){return this.values.from}
setFrom(pid){this.setAttribute(`from`,pid)}
setTitle(title=!1){if(title){this.setAttribute(`title`,title)}else{this.removeAttribute(`title`)}}
hide(){this.setAttribute(`hidden`,!0)}
isHidden(){return this.values.hidden}
reveal(){this.removeAttribute(`hidden`)}
conceal(){this.setAttribute(`concealed`,!0)}
isConcealed(){return this.values.concealed}
unconceal(){this.removeAttribute(`concealed`)}
winning(){this.setAttribute(`winning`,!0)}
isWinningTile(){return this.values.winning}
lock(locknum){this.setAttribute(`locked`,!0);if(locknum){this.setAttribute(`locknum`,locknum)}}
meld(){this.setAttribute(`meld`,!0)}
isLocked(){return this.values.locked}
getLockNumber(){return this.values.locknum}
unlock(){this.removeAttribute(`locked`);this.removeAttribute(`locknum`)}
bonus(locknum=null){this.setAttribute(`bonus`,!0);this.lock(locknum)}
isBonus(){return this.values.bonus}
supplement(){this.setAttribute(`supplement`,!0)}
isSupplement(){return this.values.supplement}
setTileFace(tile){this.setAttribute(`tile`,tile)}
getTileFace(){return this.values.tile}
getTileSuit(){let num=this.getTileFace();if(num<9)return 0;if(num<18)return 1;if(num<27)return 2;if(num<30)return 3;return 4}
valueOf(){return this.values.tile}
toString(){return `GameTile(${this.values.tile})`}}
globalThis.customElements.define(`game-tile`,GameTile);function declare(label,tilenumber){globalThis.customElements.define(label,class extends GameTile{constructor(){super(tilenumber)}})}
const numeral=[`one`,`two`,`three`,`four`,`five`,`six`,`seven`,`eight`,`nine`,];let tilenumber=0;[`bamboo`,`characters`,`dots`].forEach((suit)=>numeral.forEach((number)=>declare(`${suit}-${number}`,tilenumber++)));declare(`east-wind`,27);declare(`south-wind`,28);declare(`west-wind`,29);declare(`north-wind`,30);declare(`green-dragon`,31);declare(`red-dragon`,32);declare(`white-dragon`,33);tilenumber=34;[`flower`,`season`].forEach((b)=>numeral.slice(0,4).forEach((number)=>declare(`${b}-${number}`,tilenumber++)));const create=(tileNumber,hidden)=>{let span;if(typeof process!==`undefined`){span=new GameTile(tileNumber)}else{let GameTile=customElements.get(`game-tile`);span=new GameTile(tileNumber)}
if(tileNumber<34);else span.bonus();return span};Array.prototype.last=function last(){return this[this.length-1]};Array.prototype.asyncAll=async function asyncAll(fn){return await Promise.all(this.map((e)=>new Promise((resolve)=>{fn(e);resolve()})))};const __roll_sort=(a,b)=>(a<b?-1:b>a?1:0);function unroll(list,seen=[],result=[]){list=list.slice();seen.push(list.shift());if(!list.length){seen.sort(__roll_sort);let print=seen.toString();let found=result.some((sofar)=>sofar.toString()===print);if(!found)result.push(seen);}else list.forEach((tail)=>unroll(tail,seen.slice(),result));return result}
const VK_LEFT={"37":!0,"65":!0};const VK_RIGHT={"39":!0,"68":!0};const VK_UP={"38":!0,"87":!0};const VK_DOWN={"40":!0,"83":!0};const VK_START={"36":!0};const VK_END={"35":!0};const VK_SIGNAL={"13":!0,"32":!0};let vk_signal_lock=!1;function lock_vk_signal(){vk_signal_lock=!0;document.addEventListener('keyup',unlock_vk_signal)}
function unlock_vk_signal(evt){let code=evt.keyCode;if(VK_UP[code]||VK_SIGNAL[code]){vk_signal_lock=!1;document.removeEventListener('keyup',unlock_vk_signal)}}
class OptionsDialog{constructor(modal){this.modal=modal}
show(label,options,resolve,cancel){let panel=this.modal.makePanel();if(options.fixed)panel.fixed=!0;panel.innerHTML=`<h1>${label}</h1>`;let bid=0;let btns=[];options.filter(v=>v).forEach(data=>{if(Object.keys(data).length===0){return panel.appendChild(document.createElement('br'))}
if(data.heading){let heading=document.createElement('h1');heading.textContent=data.heading;return panel.appendChild(heading)}
if(data.description){let description=document.createElement('p');if(data.align)description.classList.add(data.align);description.textContent=data.description;return panel.appendChild(description)}
let btn=document.createElement("button");btn.textContent=data.label;btn.addEventListener("click",e=>{e.stopPropagation();if(!data.back)this.modal.close([{object:this.modal.gameBoard,evntName:'focus',handler:panel.gainFocus}]);resolve(data.value)});btn.addEventListener("keydown",e=>{e.stopPropagation();let code=e.keyCode;let willBeHandled=(VK_UP[code]||VK_DOWN[code]||VK_START[code]||VK_END[code]);if(!willBeHandled)return;e.preventDefault();if(VK_UP[code])bid=(bid===0)?btns.length-1:bid-1;if(VK_DOWN[code])bid=(bid===btns.length-1)?0:bid+1;if(VK_START[code])bid=0;if(VK_END[code])bid=btns.length-1;btns[bid].focus()});panel.appendChild(btn)});if(cancel){let handleKey=evt=>{if(evt.keyCode===27){evt.preventDefault();this.modal.close([{object:document,evntName:'focus',handler:panel.gainFocus},{object:this.modal.gameBoard,evntName:'keydown',handler:handleKey},]);cancel()}};this.modal.gameBoard.addEventListener('keydown',handleKey)}
btns=panel.querySelectorAll(`button`);panel.gainFocus=()=>btns[bid].focus();document.addEventListener('focus',panel.gainFocus);panel.addEventListener('click',panel.gainFocus);panel.addEventListener('touchstart',panel.gainFocus,{passive:!0});panel.gainFocus()}}
const WallHack={hacks:{self_drawn_win_clean:[1,1,1,2,2,2,3,3,3,4,4,4,5,16,16,16,17,17,17,18,18,18,19,19,19,27,11,11,11,12,12,12,13,13,13,14,14,14,15,6,6,6,7,7,7,8,8,8,9,9,9,10,5],self_drawn_win:[1,1,1,23,23,23,2,3,4,24,24,24,5,16,16,16,17,17,17,18,18,18,19,19,19,27,11,11,11,12,12,12,13,13,13,14,14,14,15,6,6,6,7,7,7,8,8,8,9,9,9,10,5],form_melded_kong_off_initial:[0,3,6,9,21,15,18,21,24,12,3,9,13,1,1,1,2,2,2,12,19,21,4,4,4,0,7,7,7,8,8,8,10,10,10,11,11,11,0,16,16,16,17,17,17,20,20,20,6,6,6,25,5,5,9,13,12,21,],kong_in_initial_deal:[1,1,1,2,2,2,3,3,3,4,4,4,4,16,16,16,17,17,17,18,18,18,19,19,19,5,11,11,11,12,12,12,13,13,13,14,14,14,15,6,6,6,7,7,7,8,8,8,9,9,9,10,5,5],kong_from_first_discard:[1,1,1,2,2,2,3,3,3,4,4,4,5,16,16,16,17,17,17,18,18,18,19,19,19,4,11,11,11,12,12,12,13,13,13,14,20,14,15,6,6,6,7,7,7,8,8,8,9,9,9,10,16,5],robbing_a_kong:[1,1,1,2,2,2,3,3,3,4,4,22,23,16,16,16,17,17,17,18,18,18,14,14,14,15,11,11,11,12,12,12,13,13,13,24,24,24,15,6,6,6,7,7,7,8,8,8,9,9,9,10,5,24,],robbing_a_selfdrawn_kong:[1,1,1,2,2,2,3,3,3,4,4,22,23,16,16,16,17,17,17,18,18,18,24,24,24,4,11,11,11,12,12,12,13,13,13,14,14,14,15,6,6,6,7,7,7,8,8,8,9,9,9,10,5,24,],melded_kong:[1,1,1,2,2,2,3,3,3,4,5,28,28,16,16,16,17,17,17,18,18,18,19,19,19,28,11,11,11,12,12,12,13,13,13,14,20,14,15,6,6,6,7,7,7,8,8,8,9,9,9,10,30,27,30,30,30,28,],chow_by_player_1:[1,1,1,2,2,2,3,3,3,4,4,4,5,16,16,16,17,17,17,20,20,20,23,24,26,5,11,11,11,12,12,12,13,13,13,14,14,14,26,6,6,6,7,7,7,8,8,8,9,9,9,10,25],all_bonus_to_player:[34,35,36,37,38,39,40,41,1,1,24,2,2,26,3,3,28,4,4,30,5,16,16,16,17,17,17,18,18,18,19,19,19,5,11,11,11,12,12,12,13,13,13,14,14,14,26,6,6,6,7,7,7,8,8,8,9,9,9,10,],thirteen_orphans:[0,8,9,17,18,26,27,28,29,30,31,32,33,16,16,16,17,17,17,18,18,18,19,19,19,5,11,11,11,12,12,12,13,13,13,14,14,14,26,6,6,6,7,7,7,8,8,8,9,9,9,10,27],all_green:[1,2,3,2,2,2,5,5,5,7,7,7,31,16,16,16,17,17,17,18,18,18,19,19,19,5,11,11,11,12,12,12,13,13,13,14,14,14,26,6,6,6,7,7,7,8,8,8,9,9,9,10,31],nine_gates:[0,0,0,1,2,3,4,5,6,7,8,8,8,16,16,16,17,17,17,18,18,18,19,19,19,5,11,11,11,12,12,12,13,13,13,14,14,14,26,6,6,6,7,7,7,8,8,8,9,9,9,10,3],little_three_dragons:[1,1,1,23,23,23,2,3,4,24,24,24,5,31,31,31,32,32,32,33,33,18,19,19,19,27,11,11,11,12,12,12,13,13,13,14,14,14,15,6,6,6,7,7,7,8,8,8,9,9,9,10,5],chow_for_player_0:[0,3,6,9,24,25,18,21,24,12,3,9,13,1,1,1,2,2,2,12,19,21,4,4,4,0,7,7,7,8,8,8,10,10,10,11,11,11,0,16,16,16,17,17,17,20,20,20,6,6,6,25,5,5,5,23,],'5_6_7_plus_5':[0,3,6,9,14,15,22,23,24,30,3,9,13,1,1,1,2,2,2,12,19,21,4,4,4,0,7,7,7,8,8,8,10,10,10,11,11,11,0,16,16,16,17,17,17,20,20,20,6,6,6,26,5,5,5,22,],'5_6_7_plus_6':[0,3,6,9,14,15,22,23,24,30,3,9,13,1,1,1,2,2,2,12,19,21,4,4,4,0,7,7,7,8,8,8,10,10,10,11,11,11,0,16,16,16,17,17,17,20,20,20,6,6,6,26,5,5,5,23,],'5_6_7_plus_7':[0,3,6,9,14,15,22,23,24,30,3,9,13,1,1,1,2,2,2,12,19,21,4,4,4,0,7,7,7,8,8,8,10,10,10,11,11,11,0,16,16,16,17,17,17,20,20,20,6,6,6,26,5,5,5,24,],'5_6_7_8_plus_6':[0,3,6,9,14,15,22,23,24,25,3,9,13,1,1,1,2,2,2,12,19,21,4,4,4,0,7,7,7,8,8,8,10,10,10,11,11,11,0,16,16,16,17,17,17,20,20,20,6,6,6,26,5,5,5,23,],pung_chow_conflict:[0,3,6,9,14,15,22,24,25,3,9,13,32,1,1,1,2,2,2,12,19,21,23,23,0,4,7,7,7,8,8,8,10,10,10,11,11,11,0,16,16,16,17,17,17,20,20,20,6,6,6,26,5,5,5,23,],cantonese_chicken_hand:[1,1,1,2,2,2,6,7,8,23,23,9,9,3,3,21,21,14,15,22,24,25,3,9,13,32,7,7,7,8,8,8,10,10,10,11,11,11,0,16,16,16,17,17,17,20,20,20,6,6,6,26,36,5,5,5,15,15,1,],},set(wall,tiles){tiles=tiles.slice();if(typeof tiles[0]==="object"){let conf=tiles.splice(0,1)[0];config.PRNG.seed(conf.seed||1)}else config.PRNG.seed(1);let base=wall.getBase();tiles.forEach(tile=>base.splice(base.indexOf(tile),1));wall.tiles=tiles.concat(wall.shuffle(base))}};class SettingsModal{constructor(modal){this.modal=modal}
show(){let panel=this.modal.makePanel(`settings`);panel.innerHTML=`
      <h3>Change the game settings</h3>
      <p>
        The follow settings change how the game works, but while
        the first three options are related to playing the game,
        all the other options are primarily intended for debugging.
      </p>
    `;const options=this.getOptions();const form=this.modal.buildPanelContent(options,!0);form.setAttribute("name","settings");form.setAttribute("action","index.html");form.setAttribute("method","GET");this.addFormControls(panel,form,options);this.modal.addFooter(panel,"Closing without saving")}
addFormControls(panel,form,options){const table=form.querySelector(`table`);let row=document.createElement(`tr`);row.classList.add(`spacer-1`);row.innerHTML=`
      <td>
        <input id="reload" type="reset" value="Reload">
      </td>
      <td>
        <input id="reset" type="reset" value="Reset to default settings">
      </td>
      <td>
        <input id="ok" type="submit" value="Play using these settings">
      </td>
    `;table.appendChild(row);form.addEventListener(`submit`,(evt)=>{evt.preventDefault();let mahjongConfig={};options.forEach((entry)=>{if(!entry.key)return;let value=entry.value;if(entry.value==="true")value=!0;if(entry.value==="false")value=!1;mahjongConfig[entry.key.toUpperCase()]=value});localStorage.setItem("mahjongConfig",JSON.stringify(mahjongConfig));updateCurrentConfig();try{document.getElementById("okButton").click();document.getElementById("okButton").click()}catch(_){}});let ok=table.querySelector(`#ok`);panel.gainFocus=()=>ok.focus();let reset=table.querySelector(`#reset`);reset.addEventListener("click",(evt)=>{localStorage.setItem("mahjongConfig",JSON.stringify(DEFAULT_CONFIG));updateCurrentConfig();try{document.getElementById("okButton").click();document.getElementById("okButton").click()}catch(_){}});let reload=table.querySelector(`#reload`);reload.addEventListener("click",(evt)=>{location.reload()})}
getOptions(){const disabled=globalThis.currentGame!==undefined;const options=[{label:`Rules`,key:`rules`,options:[...Ruleset.getRulesetNames()],disabled,},{},{label:`✨ Highlight claimable discards`,key:`show_claim_suggestion`,toggle:!0,},{label:`⏩ Auto-skip non-claimable discards`,key:`auto_skip_discards`,toggle:!0,},{label:`💬 Show bot play suggestions`,key:`show_bot_suggestion`,toggle:!0,},{label:`🧠 Show tile tracking panel`,key:`show_tile_tracker`,toggle:!0,},{},{label:`🎵 Play sounds`,key:`use_sound`,toggle:!0,},{label:`🟢 Start play immediately`,key:`play_immediately`,toggle:!0,},{label:`⏸️ Pause game unless focused`,key:`pause_on_blur`,toggle:!0,disabled,},{label:`❌ Pretend previous round was a draw`,key:`force_draw`,toggle:!0,debug_only:!0,},{label:`📃 Generate game log after play`,key:`write_game_log`,toggle:!0,debug_only:!0,},{},{label:`Set game PRNG seed`,key:`seed`,debug_only:!0,},{label:`Bot quick play threshold`,key:`bot_chicken_threshold`,debug_only:!0,},{label:`Delay (in ms) to claim a discard`,key:`claim_interval`,},{label:`Delay (in ms) between player turns`,key:`play_interval`,},{label:`Delay (in ms) before starting next hand`,key:`hand_interval`,},{label:`Delay (in ms) for bots reacting to things`,key:`bot_delay_before_discard_ends`,},{label:`Delay (in ms) during full bot play`,key:`bot_play_delay`,},{label:`Set up a specific wall`,key:`wall_hack`,options:[``,...Object.keys(WallHack.hacks)],debug_only:!0,},];options.forEach((entry)=>{const{key}=entry;if(key){const CONFIG_KEY=key.toUpperCase();entry.value=config[CONFIG_KEY];entry.default_value=config.DEFAULT_CONFIG[CONFIG_KEY]}});return options}}
class ScoreModal{constructor(modal){this.modal=modal}
showFinalScores(gameui,rules,scoreHistory,resolve){let panel=this.modal.makePanel(`final-scores`);panel.innerHTML=`<h3>Game finished</h3>`;let base=new Array(4).fill(rules.player_start_score);let table=document.createElement('table');let tbody=document.createElement('tbody');table.appendChild(tbody);tbody.innerHTML=`
      <tr>
        <th>hand</th>
        <th>player 0</th>
        <th>player 1</th>
        <th>player 2</th>
        <th>player 3</th>
        <th>&nbsp;</th>
      </tr>
      <tr>
        <td>&nbsp;</td>
        ${base.map(v => `<td>${v}</td>`).join('\n')}
        <td>&nbsp;</td>
      </tr>
    `;scoreHistory.forEach((record,hand)=>{hand=hand+1;let row=document.createElement('tr');let content=[0,1,2,3].map(id=>{let winner=record.fullDisclosure[id].winner;let value=record.adjustments[id];let score=(base[id]=base[id]+value);let wind=record.fullDisclosure[id].wind;let title=[winner?'winner':!1,wind===0?'east':!1].filter(v=>v).join(', ');return `
          <td title="${title}">
            <span${wind===0 ? ` class="east"`:``} >${winner ? `<strong>${score}</strong>` : score}</span>
          </td>
        `});row.innerHTML=`
        <td>${hand}</td>
        ${content.join('\n')}
        <td><button>details</button></td>
      `;row.querySelector('button').addEventListener('click',()=>{gameui.loadHandPostGame(record.fullDisclosure);this.show(hand,rules,record.scores,record.adjustments)});tbody.appendChild(row)});panel.appendChild(table);this.modal.addFooter(panel,"Back to the menu",resolve);panel.scrollTop=0}
show(hand,rules,scores,adjustments,resolve){let panel=this.modal.makePanel(`scores`);panel.innerHTML=`<h3>Scores for hand ${hand}</h3>`;let faanSystem=(rules.scoretype===Ruleset.FAAN_LAAK);let winner=0;scores.some((e,id)=>{winner=id;return e.winner});let builder=document.createElement('div');builder.innerHTML=`
    <table>
      <tr>
        <th>&nbsp;</th>
        <th>player 0</th>
        <th>player 1</th>
        <th>player 2</th>
        <th>player 3</th>
      </tr>
      <tr>
        <td>winner</td>
        <td>${scores[0].winner ? '*' : ''}</td>
        <td>${scores[1].winner ? '*' : ''}</td>
        <td>${scores[2].winner ? '*' : ''}</td>
        <td>${scores[3].winner ? '*' : ''}</td>
      </tr>
      <tr>
        <td>${faanSystem ? `points` : `basic`}</td>
        <td>${scores[0].score}</td>
        <td>${scores[1].score}</td>
        <td>${scores[2].score}</td>
        <td>${scores[3].score}</td>
      </tr>
      ${faanSystem ? `` : `<tr><td>doubles</td><td>${scores[0].doubles}</td><td>${scores[1].doubles}</td><td>${scores[2].doubles}</td><td>${scores[3].doubles}</td></tr>`}
      <tr>
        <td>total</td>
        <td>${scores[0].total}</td>
        <td>${scores[1].total}</td>
        <td>${scores[2].total}</td>
        <td>${scores[3].total}</td>
      </tr>
      <tr>
        <td>win/loss</td>
        <td>${adjustments[0]}</td>
        <td>${adjustments[1]}</td>
        <td>${adjustments[2]}</td>
        <td>${adjustments[3]}</td>
      </tr>
      <tr class="details">
        <td>&nbsp;</td>
        <td>${ !faanSystem || (faanSystem && winner===0) ? `<button>details</button>` : ``}</td>
        <td>${ !faanSystem || (faanSystem && winner===1) ? `<button>details</button>` : ``}</td>
        <td>${ !faanSystem || (faanSystem && winner===2) ? `<button>details</button>` : ``}</td>
        <td>${ !faanSystem || (faanSystem && winner===3) ? `<button>details</button>` : ``}</td>
      </tr>
    </table>
    `;let table=builder.querySelector('table');Array.from(table.querySelectorAll('tr.details td')).slice(1).map((e,pid)=>{e.addEventListener('click',evt=>{this.showScoreDetails(pid,scores[pid].log,faanSystem)})});panel.appendChild(table);if(resolve)this.modal.addFooter(panel,"Play next hand",resolve,!0);else this.modal.addFooter(panel,"OK")}
showScoreDetails(pid,log,faanSystem){let panel=this.modal.makePanel(`score-breakdown`);panel.innerHTML=`<h3>Score breakdown for player ${pid}</h3>`;let table=document.createElement('table');let data=[`<tr><th>points</th><th>element</th></tr>`,...log.map(line=>{let mark=` for `;if(line.indexOf(mark)>-1){let parts=line.split(mark);let pts=parts[0].replace(/doubles?/,`dbl`).replace(/faan/,'');return `<tr><td>${pts}</td><td>${parts[1]}</td></tr>`}else{if(faanSystem)return ``;return `<tr><td colspan="2">${line}</td></tr>`}})];table.innerHTML=data.join(`\n`);panel.appendChild(table);this.modal.addFooter(panel,"Back to the scores")}}
function setStyleSheet(id,css){let style=document.getElementById(id);if(style){style.parentNode.removeChild(style)}else{style=document.createElement(`style`)}
style.id=id;style.textContent=css;document.body.append(style)}
class Modal{constructor(fixed=!1){this.fixed=fixed;this.modal=document.querySelector(".modal");this.gameBoard=document.querySelector(".board");this.panels=[];this.choice=new OptionsDialog(this);this.settings=new SettingsModal(this);this.scores=new ScoreModal(this)}
reveal(){this.modal.classList.remove("hidden")}
isHidden(){return this.modal.classList.contains("hidden")}
hide(){this.modal.classList.add("hidden")}
makePanel(name){let panels=this.panels;let panel=document.createElement("div");panel.classList.add("panel");if(name)panel.classList.add(name);panels.forEach((p)=>(p.style.display="none"));panels.push(panel);this.modal.appendChild(panel);return panel}
close(unbind=[]){unbind.forEach((opt)=>{opt.object.addEventListener(opt.evtName,opt.handler)});let modal=this.modal;let panels=this.panels;let panel=panels.pop();if(panel)modal.removeChild(panel);if(panels.length){let panel=panels[panels.length-1];panel.style.display="block";if(panel.gainFocus)panel.gainFocus();}else{this.hide();this.gameBoard.focus()}}
buildPanelContent(options,wrapInForm=!1){const debug=config.DEBUG;const form=wrapInForm?document.createElement(`form`):undefined;const table=document.createElement(`table`);this.panels.last().append(table);options.forEach((entry)=>{const{label,button_label,key,value,default_value}=entry;const{toggle,type,evtType,handler,debug_only,disabled}=entry;let options=entry.options;let row;if(!label){row=document.createElement(`tr`);row.innerHTML=`<td colspan="2">&nbsp;</td>`;return table.appendChild(row)}
if(debug_only&&!debug){return}
row=document.createElement(`tr`);let field=`<input id="${key}" class="${key} field" type"${
        type || `text`
      }" value="${value}">`;if(options||toggle){options=toggle?[!0,!1]:options;field=`
          <select id="${key}" class="${key} field"${disabled? " disabled" : ""}>
            ${options.map(
              (opt) =>
                `<option value="${opt}"${opt===value?` selected`:``}>${`${opt}`.replace(/_/g," ")}</option>`
            )}
          </select>`}
if(type===`file`){field=`<input class="${key} picker field" type="${type}" value="pick...">`}
if(type===`button`){field=`<input class="${key} picker field" type="${type}" value="${button_label}">`}
if(type===`color`){field=`<input class="${key} picker field" type="${type}" value="${value.substring(
          0,
          7
        )}">`;if(value.length===9){field+=`<input class="${key} opacity" type="range" min="0" max="255" step="1" value="${parseInt(
            value.substring(7),
            16
          )}">`}}
row.innerHTML=`
        <td colspan="2" style="white-space: nowrap;" data-toggle="${key}" ${
        toggle && !value ? `class="greyed"` : ``
      }>${label}</td>
        <td ${value != default_value ? ` class="custom"` : ``}>${field}</td>
      `;table.appendChild(row);const input=row.querySelector(`.field`);input.addEventListener(evtType||`input`,(evt)=>{if(handler){handler(entry,evt)}else{entry.value=evt.target.value}});input.addEventListener(`input`,()=>{if(input.value!==default_value.toString()){input.parentNode.classList.add(`custom`)}else{input.parentNode.classList.remove(`custom`)}});if(toggle){const inputLabel=row.querySelector(`[data-toggle="${key}"]`);input.addEventListener(`input`,()=>inputLabel.classList.toggle(`greyed`))}
if(type===`color`){const opacity=row.querySelector(`.field + .opacity`);if(opacity){opacity.addEventListener(`input`,(evt)=>{handler(entry,!1,evt.target.value)})}}});if(wrapInForm){form.append(table);this.panels.last().append(form);return form}
this.panels.last().append(table);return table}
addFooter(panel,modalLabel="OK",resolve=()=>{},botDismissible){let ok=document.createElement("button");ok.id="okButton";ok.textContent=modalLabel;ok.addEventListener("click",()=>{this.close([{object:document,evntName:"focus",handler:panel.gainFocus},]);resolve();if(modalLabel==="Back to the scores")return;try{document.getElementById("okButton").click()}catch(_){}});panel.appendChild(ok);if(config.BOT_PLAY&&botDismissible){let dismiss=()=>ok.click();setTimeout(()=>dismiss(),config.HAND_INTERVAL);panel.addEventListener("click",()=>(dismiss=()=>{}))}
panel.gainFocus=()=>ok.focus();document.addEventListener("focus",panel.gainFocus);let defaultFocus=(evt)=>{let name=evt.target.nodeName.toLowerCase();if(name==="select"||name==="input")return;panel.gainFocus()};panel.addEventListener("click",defaultFocus);panel.addEventListener("touchstart",defaultFocus,{passive:!0});panel.gainFocus()}
choiceInput(label,options,resolve,cancel){this.reveal();this.choice.show(label,options,resolve,cancel)}
setScores(hand,rules,scores,adjustments,resolve){this.reveal();this.scores.show(hand,rules,scores,adjustments,resolve)}
showFinalScores(gameui,rules,scoreHistory,resolve){this.reveal();this.scores.showFinalScores(gameui,rules,scoreHistory,resolve)}
pickPlaySettings(){try{if(globalThis.currentGame.game.currentPlayerId>0)return}catch(_){}
this.reveal();this.settings=new SettingsModal(this);this.settings.show()}}
let modal=new Modal();class TileTracker{constructor(id,tiles=null){this.id=id;this.tiles=tiles?tiles:[];this.ui=!1;this.reset()}
setUI(ui){this.ui=ui}
reset(){let tiles=(new Array(34)).fill(4);tiles.push(1,1,1,1,1,1,1,1);this.tiles=Object.assign({},tiles);if(this.ui)this.ui.resetTracker(this.tiles);}
get(tileNumber){return this.tiles[tileNumber]}
seen(tileNumber){if(tileNumber.dataset){console.log(`Player ${this.id} tracker was passed an HTMLElement instead of a tile`);console.trace();throw new Error('why is the tracker being given an HTML element?')}
if(this.tiles[tileNumber]>0){this.tiles[tileNumber]--;if(this.ui)this.ui.reduceTracker(tileNumber);}}}
class PlayerMaster{constructor(id){this.el=document.createElement('div');this.el.setAttribute('class','player');this.el.id=id;this.id=id;this.tracker=new TileTracker(this.id);this.ui=!1;this.wincount=0;this.reset()}
reset(wind,windOfTheRound,hand,draws){this.wind=wind;this.windOfTheRound=windOfTheRound;this.draws=draws;this.discards=[];this.tiles=[];this.locked=[];this.bonus=[];this.waiting=!1;this.has_won=!1;this.selfdraw=!1;this.robbed=!1;this.tracker.reset();this.el.innerHTML='';this.el.classList.add('winner');if(this.ui)this.ui.reset(wind,windOfTheRound,hand,draws);}
pause(lock){this.paused=lock;if(this.ui)this.ui.pause(lock);}
resume(){if(this.ui)this.ui.resume();this.paused=!1}
gameWillStart(game,rules){if(this.ui)this.ui.gameWillStart();this.setActiveGame(game);this.setRules(rules)}
setActiveGame(game){this.game=game}
setRules(rules){this.rules=rules;this._score=this.rules.player_start_score;if(this.ui)this.ui.setRules(rules);}
handWillStart(redraw,resolve){if(this.ui)this.ui.handWillStart(redraw,resolve);else resolve();document.querySelectorAll(".winner").forEach(el=>el.classList.remove("winner"));document.querySelectorAll(".waiting").forEach(el=>el.classList.remove("waiting"))}
playWillStart(){if(this.ui)this.ui.playWillStart();}
markTilesLeft(left,dead){this.tilesLeft=left;this.tilesDead=dead;if(this.ui)this.ui.markTilesLeft(left,dead);}
getDisclosure(){this.discards=this.discards.filter(t=>t);return{concealed:this.getTileFaces().filter(v=>v<34),locked:this.locked,bonus:this.bonus,discards:this.discards.map(t=>t.getTileFace?t.getTileFace():t),wind:this.wind,winner:this.has_won,wincount:this.getWinCount(),selfdraw:this.has_won?this.selfdraw:!1,selftile:(this.has_won&&this.selfdraw)?this.latest:!1,robbed:this.robbed,final:this.has_won?this.latest.getTileFace():!1}}
endOfHand(fullDisclosure){if(this.ui)this.ui.endOfHand(fullDisclosure);}
endOfGame(scores){if(this.ui)this.ui.endOfGame(scores);}
recordScores(adjustments){this._score+=adjustments[this.id];if(this.ui)this.ui.recordScores(adjustments);}
getScore(){return this._score}
activate(id){if(this.ui)this.ui.activate(id);}
disable(){if(this.ui)this.ui.disable();}
markWaiting(winTiles={}){this.waiting=winTiles;if(this.ui)this.ui.markWaiting(winTiles);}
markWinner(){if(!this.has_won){this.has_won=!0;this.wincount++;if(this.ui)this.ui.markWinner(this.wincount);}}
getWinCount(){return this.wincount}
append(tile,claimed,supplement){let face;let revealed=!1;if(typeof tile!=='object'){face=tile;tile=create(tile)}else{face=tile.getTileFace()}
this.latest=tile;if(tile.isBonus()){revealed=face;this.bonus.push(face)}else{this.tiles.push(tile)}
if(!claimed){this.tracker.seen(tile.getTileFace());this.lastClaim=!1}
if(supplement)tile.supplement();if(this.ui)this.ui.append(tile);return revealed}
remove(tile){let pos=this.tiles.indexOf(tile);this.tiles.splice(pos,1);if(this.ui)this.ui.remove(tile);}
mayChow(pid){return((pid+1)%4==this.id)}
meldKong(tile){this.remove(tile);let set=this.locked.find(set=>(set[0].getTileFace()===tile.getTileFace()));let meld=set[0].cloneNode(!0);meld.meld();set.push(meld);if(this.ui)this.ui.meldKong(tile);}
async checkKong(){return!1}
see(tiles,player){if(player===this)return;if(!tiles.map)tiles=[tiles];tiles.forEach(tile=>this.tracker.seen(tile));if(this.ui)this.ui.see(tiles,player);}
receivedTile(player){if(this.ui)this.ui.receivedTile(player);}
tilesNeeded(excludeTile=null){return tilesNeeded(this.getTileFaces(),this.locked,excludeTile)}
playerDiscarded(player,discard,playcounter){let tile=discard.getTileFace();if(this.id!=player.id)this.tracker.seen(tile);if(this.ui)this.ui.playerDiscarded(player,tile,playcounter);}
async seeKong(tiles,player,tilesRemaining,resolve){this.see(tiles.map(t=>t.getTileFace()),player);this.robKong(player.id,tiles,tilesRemaining,resolve)}
async robKong(pid,tiles,tilesRemaining,resolve){resolve()}
giveUpKongTile(tile){let set=this.locked.find(set=>set.length===4&&set[0].getTileFace()===tile);let discard=set.splice(0,1)[0];discard.unconceal();return discard}
playerGaveUpKongTile(pid,tilenumber){if(this.ui)this.ui.playerGaveUpKongTile(pid,tilenumber);}
seeClaim(tiles,player,claimedTile,claim){if(player===this)return;if(!tiles.map)tiles=[tiles];tiles.forEach((tile,pos)=>{if(tile===claimedTile)return;this.tracker.seen(tile.getTileFace())});if(this.ui)this.ui.seeClaim(tiles,player,claim);}
nextPlayer(){if(this.ui)this.ui.nextPlayer();}
getAvailableTiles(){return this.tiles}
getSingleTileFromHand(tile){return this.tiles.find(t=>(t.getTileFace()==tile))}
getAllTilesInHand(tile){return this.tiles.filter(t=>(t.getTileFace()==tile))}
getTiles(allTiles){return allTiles?[...this.tiles,...this.bonus]:this.tiles}
getTileFaces(allTiles){return this.getTiles(allTiles).map(t=>(t.getTileFace?t.getTileFace():t)).sort((a,b)=>(a-b))}
getLockedTileFaces(){return this.locked.map(set=>`[${set.map(v=>v.getTileFace()).sort((a,b)=>(a-b))}]${set.winning?'!':''}`)}
sortTiles(){if(this.ui)this.ui.sortTiles();}
async chowExists(pid,tile){if(tile>26)return CLAIM.IGNORE;let next=(pid+1)%4;let valid=next==this.id;if(!valid)return CLAIM.IGNORE;let tiles=this.getTileFaces();let face=tile%9;let tm2=(face>1)?tiles.indexOf(tile-2)>=0:!1;let tm1=(face>0)?tiles.indexOf(tile-1)>=0:!1;let t1=(face<8)?tiles.indexOf(tile+1)>=0:!1;let t2=(face<7)?tiles.indexOf(tile+2)>=0:!1;let c1=t1&&t2;let c2=tm1&&t1;let c3=tm2&&tm1;if(c1)return CLAIM.CHOW1;if(c3)return CLAIM.CHOW3;if(c2)return CLAIM.CHOW2;return CLAIM.IGNORE}}
class TaskTimer{static id=0;static timers={};constructor(startWaiting,timeoutFunction,timeoutInterval,signalHandler=!1,signalCount=0){this.id=TaskTimer.id++;this.paused=!1;this.created=Date.now();this.overrideKickedIn=!1;this.timeoutInterval=timeoutInterval;this.timeoutFunction=()=>{TaskTimer.__forget__(this);timeoutFunction()};if(signalHandler&&signalCount>0){this.signalHandler=signalHandler;this.totalSignalCount=signalCount+1;if(this.totalSignalCount<1)this.totalSignalCount=1;this.signalCount=this.totalSignalCount;this.sendSignal()}
setTimeout(()=>startWaiting(this),0);this.startTimeout();TaskTimer.__record__(this)}
static __record__(timer){TaskTimer.timers[timer.id]=timer}
static __forget__(timer){delete TaskTimer.timers[timer.id]}
startTimeout(){this.overrideTrigger=setTimeout(()=>{this.overrideKickedIn=!0;this.timeoutFunction()},this.timeoutInterval)}
sendSignal(){let handler=this.signalHandler;if(!handler)return;let signalNumber=this.totalSignalCount-(this.signalCount--);handler(signalNumber);if(!this.isPaused()&&this.signalCount>0){let elapsed=Date.now()-this.created;let remaining=this.timeoutInterval-elapsed;let timeoutValue=remaining/this.signalCount;this.nextSignal=setTimeout(()=>this.sendSignal(),timeoutValue)}}
hasTimedOut(){return this.overrideKickedIn}
cancel(__preserveTimer){if(this.nextSignal)clearTimeout(this.nextSignal);if(!this.overrideKickedIn){clearTimeout(this.overrideTrigger);if(!__preserveTimer){if(this.signalHandler)this.signalHandler(this.totalSignalCount-1);TaskTimer.__forget__(this)}}}
isPaused(){return this.paused}
pause(){this.cancel(!0);let elapsed=Date.now()-this.created;this.timeoutInterval=this.timeoutInterval-elapsed;let resolver=resolve=>(this._resolve_pause_lock=resolve);this.paused=new Promise(resolver);return this.paused}
resume(){if(this._resolve_pause_lock){this.paused=!1;this.created=Date.now();this._resolve_pause_lock();this.startTimeout();this.sendSignal()}}
static pause(){for(timer of TaskTimer.timers)timer.pause();if(!TaskTimer.paused){let resolver=resolve=>(TaskTimer._resolve_pause_lock=resolve);TaskTimer.paused=new Promise(resolver)}
return TaskTimer.paused}
static resume(){TaskTimer._resolve_pause_lock();TaskTimer.paused=!1;for(timer of TaskTimer.timers)timer.resume()}}
TaskTimer.id=0;TaskTimer.timers={};class Player extends PlayerMaster{constructor(id){super(id)}
async getDiscard(tilesRemaining,resolve){let resolveProxy=(discard)=>{if(!discard)return resolve(discard);discard.values.from=this.id;discard.setFrom(this.id);this.discards.push(discard);this.game.discards.push(discard);resolve(discard)};return this.determineDiscard(tilesRemaining,resolveProxy)}
determineDiscard(tilesRemaining,resolve){resolve(undefined)}
async getClaim(pid,discard,tilesRemaining,resolve){if(pid==this.id)return resolve({claimtype:CLAIM$1.IGNORE});new TaskTimer(timer=>{let claimfn=claim=>timer.hasTimedOut()?!1:resolve(claim);let cancelfn=()=>timer.cancel();this.determineClaim(pid,discard,tilesRemaining,claimfn,cancelfn,timer)},()=>resolve({claimtype:CLAIM$1.IGNORE}),config.CLAIM_INTERVAL)}
determineClaim(pid,discard,tilesRemaining,resolve,interrupt,claimTimer){resolve({claimtype:CLAIM$1.IGNORE})}
receiveDiscardForClaim(claim,discard){this.lastClaim=claim;let tile=discard.getTileFace();let claimtype=claim.claimtype;let set=[];set.push(discard);set.locked=!0;if(claimtype===CLAIM$1.WIN){this.markWinner();if(!set.winning)claimtype=claim.wintype;set.winning=!0;if(claimtype===CLAIM$1.CHOW){claimtype=convertSubtypeToClaim(claimtype)}}
this.append(discard,!0);discard.lock();if(this.has_won)discard.winning();if(claimtype===CLAIM$1.PAIR||claimtype===CLAIM$1.PUNG||claimtype===CLAIM$1.KONG){let count=0;if(claimtype===CLAIM$1.PAIR)count=1;if(claimtype===CLAIM$1.PUNG)count=2;if(claimtype===CLAIM$1.KONG)count=3;let tiles=this.getAllTilesInHand(tile);tiles=Array.from(tiles).slice(0,count);Array.from(tiles).forEach(t=>{if(t.getTileFace()==tile){t.reveal();t.lock();if(this.has_won)t.winning();set.push(t)}});this.lockClaim(set);return set}
let t1,t2;if(claimtype===CLAIM$1.CHOW1){t1=this.getSingleTileFromHand(tile+2);t2=this.getSingleTileFromHand(tile+1)}else if(claimtype===CLAIM$1.CHOW2){t1=this.getSingleTileFromHand(tile+1);t2=this.getSingleTileFromHand(tile-1)}else if(claimtype===CLAIM$1.CHOW3){t1=this.getSingleTileFromHand(tile-1);t2=this.getSingleTileFromHand(tile-2)}[t1,t2].forEach(t=>{t.reveal();t.lock();if(this.has_won)t.winning();set.push(t)});this.lockClaim(set);return set}
lockClaim(tiles,concealed=!1){let kong=(tiles.length===4);tiles.forEach(tile=>{this.remove(tile);tile.unmark('latest');tile.setTitle(``);tile.lock();if(kong)tile.conceal();});if(kong&&!concealed){delete tiles[0].conceal()}
this.locked.push(tiles);if(this.ui)this.ui.lockClaim(tiles);}}
function buildStatsContainer(player){let tiles=player.tiles.map(t=>t.getTileFace()).sort();let locked=player.locked.map(s=>s.map(t=>t.getTileFace()).sort());let tileCount=(new Array(42)).fill(0);let suit=t=>(t/9)|0;let stats={cpairs:0,pairs:0,chows:0,pungs:0,bigpungs:0,tiles:0,counts:{},numerals:0,terminals:0,honours:0,winds:0,dragons:0,suits:[0,0,0],locked:{chows:0,pungs:0,bigpungs:0,tiles:0,numerals:0,suits:[0,0,0]}};locked.forEach(set=>{let tileNumber=set[0];if(tileNumber===set[1]){stats.pungs++;stats.locked.pungs++;if(tileNumber<27){stats.numerals+=set.length;stats.locked.numerals+=set.length;stats.suits[suit(tileNumber)]++;stats.locked.suits[suit(tileNumber)]++}
if(tileNumber+27===player.wind){stats.bigpungs++;stats.locked.bigpungs++}
if(tileNumber+27===player.windOfTheRound){stats.bigpungs++;stats.locked.bigpungs++}
if(tileNumber>30){stats.bigpungs++;stats.locked.bigpungs++}}else{stats.chows++;stats.locked.chows++;stats.numerals+=set.length;stats.locked.numerals+=set.length;stats.suits[suit(tileNumber)]++;stats.locked.suits[suit(tileNumber)]++}
stats.tiles+=set.length;stats.locked.tiles+=set.length});tiles.forEach(tileNumber=>{if(tileNumber<=26){stats.numerals++;let face=(tileNumber%9);if(face===0||face===8)stats.terminals++;stats.suits[suit(tileNumber)]++}else{stats.honours++;if(26<tileNumber&&tileNumber<=30)stats.winds++;if(30<tileNumber&&tileNumber<=33)stats.dragons++}
tileCount[tileNumber]++;stats.tiles++;if(!stats.counts[tileNumber])stats.counts[tileNumber]=0;stats.counts[tileNumber]++});tileCount.forEach((count,tileNumber)=>{if(count&&tileNumber<=24){let c2,c3;let tsuit=suit(tileNumber);let t2=tileNumber+1;if(suit(t2)===tsuit){c2=tileCount[t2];let t3=tileNumber+2;if(suit(t3)===tsuit){c3=tileCount[t3]}}
if(c2&&c3)stats.chows++;else if(c2||c3)stats.cpairs++}
if(count===2)stats.pairs++;if(count>=3){stats.pungs++;if(tileNumber+27===player.wind){stats.bigpungs++}
if(tileNumber+27===player.windOfTheRound){stats.bigpungs++}
if(tileNumber>30){stats.bigpungs++}}});return stats}
class Personality{constructor(player,personalityObj=null){this.player=player;if(personalityObj){this.allowScoringChicken=personalityObj.allowScoringChicken;this.cleanThreshold_low=personalityObj.cleanThreshold_low;this.cleanThreshold_high=personalityObj.cleanThreshold_high;this.playClean=personalityObj.playClean;this.playChowHand=personalityObj.playChowHand;this.chickenThreshold=personalityObj.chickenThreshold;this.chicken=personalityObj.chicken;this.basePanicThreshold=personalityObj.basePanicThreshold;this.panicThreshold=personalityObj.panicThreshold}else{this.allowScoringChicken=!0;this.cleanThreshold_low=0.6;this.cleanThreshold_high=0.7;this.playClean=!1;this.playChowHand=!1;this.chickenThreshold=config.BOT_CHICKEN_THRESHOLD;this.chicken=!1;this.basePanicThreshold=16;this.panicThreshold=this.basePanicThreshold}}
checkChicken(tilesRemaining){if(this.chicken)return;if(this.chickenThreshold<1&&tilesRemaining<this.panicThreshold){this.chickenThreshold+=this.chickenThreshold}
if(config.PRNG.nextFloat()<this.chickenThreshold){this.chicken=!0;let notice=`player ${this.player.id} will be going for chicken hands at ${tilesRemaining} tiles left!`;config.log(notice)}}
suit(t){return(t/9)|0}
setDraws(draws=0){this.panicThreshold=this.basePanicThreshold+draws*this.basePanicThreshold;console.debug(`panic for ${this.player.id} set to ${this.panicThreshold}`)}
determinePersonality(){this.chickenThreshold=config.BOT_CHICKEN_THRESHOLD;this.chicken=!1;this.analyse()}
analyse(){let player=this.player;let stats=buildStatsContainer(player);let most=max(...stats.suits);let total=stats.numerals;if(this.playClean===!1&&!this.stopClean&&most/total>this.cleanThreshold_high){this.playClean=stats.suits.indexOf(most);console.debug(`${player.id} will play clean (${this.playClean})`)}
if(this.playClean!==!1){if(player.locked.length>0){let mismatch=player.locked.some(set=>set[0].getTileFace()!==this.playClean);if(mismatch){this.playClean=!1}}
if(most/total<this.cleanThreshold_low){this.playClean=!1}
if(this.playClean===!1){this.stopClean=!0;console.debug(`${player.id} will stop trying to play clean.`)}}
if(!player.locked.length){let chowScore=stats.cpairs/2+stats.chows;this.playChowHand=(stats.honours<=3&&chowScore>=2&&stats.pungs<stats.chows)}
return stats}
want(tileNumber,reason,tilesRemaining){this.checkChicken(tilesRemaining);if(this.chicken){console.debug(this.player.id,'is going for chickens');return!0}
let stats=this.analyse();if(!1===this.checkClean(tileNumber,reason,tilesRemaining))return!1;if(!this.checkChow(tileNumber,reason,tilesRemaining,stats))return!1;if(!this.checkPung(tileNumber,reason,tilesRemaining,stats))return!1;return!0}
checkClean(tileNumber,reason,tilesRemaining,stats=!1){if(this.playClean!==!1&&tileNumber<27){let tilesuit=this.suit(tileNumber);if(tilesuit!==this.playClean){console.debug(this.player.id,'not claiming ',tileNumber,'due to playing clean','(',tilesRemaining,'left)');return!1}}
if(stats){console.debug(this.player.id,`checkClean with stats`.stats);let scount=stats.suits.reduce((t,v)=>v>0?t+1:t,0);if(scount>1){console.debug(this.player.id,`trying to win clean, so we can't claim ${tileNumber} to win`);console.debug(this.player.id,this.playClean,tileNumber);if(reason>=CLAIM$1.CHOW){console.debug(this.player.id,`claim ${reason}`);return reason}
console.debug(this.player.id,`no claim`);return!1}}
return!0}
checkChow(tileNumber,reason,tilesRemaining,stats){if(CLAIM$1.CHOW<=reason&&reason<CLAIM$1.PUNG){let canChicken=this.allowScoringChicken&&(stats.bigpungs>0||stats.locked.bigpungs>0);if(stats.locked.pungs>0&&!canChicken){console.debug(this.player.id,'not claiming chow because we have a pung','(',tilesRemaining,'left)');return!1}}
return!0}
checkPung(tileNumber,reason,tilesRemaining,stats){if(reason===CLAIM$1.PUNG||reason===CLAIM$1.KONG){let canChicken=this.allowScoringChicken&&(stats.bigpungs>0||stats.locked.bigpungs>0);let isBig=(tileNumber+27===this.player.wind)||(tileNumber+27===this.player.windOfTheRound)||(tileNumber>30);if((this.playChowHand||stats.locked.chows)>0&&!canChicken&&!isBig){console.debug(this.player.id,'not claiming pung/kong because we have a chow, and',tileNumber,'is not scoring','(',tilesRemaining,'left)');return!1}}
return!0}
determineWhetherToWin(tileNumber,reason,tilesRemaining){this.checkChicken(tilesRemaining);if(this.chicken){console.debug(this.player.id,'is going for chickens');return!0}
let stats=this.analyse();let cleancheck=this.checkClean(tileNumber,reason,tilesRemaining,stats);if(cleancheck!==!0)return cleancheck;if(!this.checkChow(tileNumber,reason,tilesRemaining,stats))return!1;if(!this.checkPung(tileNumber,reason,tilesRemaining,stats))return!1;return!0}
isValidWin(tilesRemaining){this.checkChicken(tilesRemaining);if(this.chicken){console.debug(this.player.id,'is going for chickens');return!0}
let stats=this.analyse();let canChicken=this.allowScoringChicken&&(stats.bigpungs>0||stats.locked.bigpungs>0);let scount=stats.suits.reduce((t,v)=>v>0?t+1:t,0);console.debug(this.player.id,this.playClean,scount,stats);if(this.playClean!==!1&&scount>1){if(!canChicken)return!1}
if(stats.pungs>0&&stats.chows>0){if(!canChicken)return!1}
return!0}
deadTile(tile,tilesRemaining){this.checkChicken(tilesRemaining);if(this.chicken)return!1;if(this.playClean!==!1&&tile<27){let suit=this.suit(tile);if(this.playClean!==suit){return this.player.tiles.map(t=>this.suit(t.getTileFace())).filter(s=>s===suit).length}}
let stats=this.analyse();if(stats.locked.chows>0&&stats.counts[tile]>2){return!0}
return!1}}
class BotPlayer extends Player{constructor(id,chicken=!1){super(id);this.personality=new Personality(this);this.chicken=chicken;if(config.FORCE_OPEN_BOT_PLAY)this.enableShowTilesAnyway();}
reset(hand,wind,windOfTheRound,draws){super.reset(hand,wind,windOfTheRound,draws);if(this.personality){this.personality.setDraws(this.draws);if(this.chicken)this.personality.chicken=!0}}
showTilesAnyway(){}
enableShowTilesAnyway(){this.showTilesAnyway=()=>{if(!config.FORCE_OPEN_BOT_PLAY)return;if(globalThis.PLAYER_BANKS&&this.id!==0){let bank=globalThis.PLAYER_BANKS[this.id];bank.innerHTML='';this.getTileFaces().forEach(t=>{t=create(t);bank.appendChild(t)});this.locked.forEach((s,sid)=>{s.forEach(t=>{t.lock(1+sid);bank.appendChild(t)})});this.bonus.forEach(t=>{t=create(t);t.lock();bank.appendChild(t)});if(this.waiting)bank.classList.add('waiting');else bank.classList.remove('waiting');globalThis.PLAYER_BANKS.sortTiles(bank)}}}
append(tile,claimed,supplement){let _=super.append(tile,claimed,supplement);this.showTilesAnyway();return _}
remove(tile){super.remove(tile);this.showTilesAnyway()}
playWillStart(){super.playWillStart();this.personality.determinePersonality()}
determineDiscard(tilesRemaining,resolve,showAllSuggestions){if(this.has_won)return resolve(undefined);let tiles=this.getAvailableTiles();if(!tiles.length)return resolve(undefined);let{winpaths}=this.tilesNeeded();if(winpaths.length>0){if(this.personality.isValidWin(tilesRemaining)){if(!this.lastClaim){this.selfdraw=!0;console.debug(`Self-drawn win for player ${this.id} on ${this.latest.getTileFace()}`)}
return resolve(undefined)}
this.waiting=!1}
if(this.waiting)return resolve(this.determineWhatToWaitFor());let allTiles=this.getTileFaces(!0).filter(t=>t<34);let limithand=this.rules.checkForLimit(allTiles);if(limithand)return resolve(undefined);this.determineDiscardCarefully(tilesRemaining,resolve,showAllSuggestions)}
determineWhatToWaitFor(){console.debug(this.id,"waiting to win but",this.latest,"is not in our wait list",this.waiting);let winTiles=Object.keys(this.waiting);if(winTiles.length===1){let tileNumber=(winTiles[0]|0);let ways=this.waiting[tileNumber];if(ways.length===1&&ways[0]==="32s1"){let had=this.getSingleTileFromHand(tileNumber);let received=this.latest;console.debug(`${this.id} has two singles in hand:`,had,received);let tile=this.determineWhichPairTileToThrow(had,received);console.debug(`${this.id} wants to throw out:`,tile);if(tile===had){let nid=received.getTileFace();let oid=had.getTileFace();console.debug(`${this.id} swapping win information from ${oid} to ${nid}`);this.waiting[nid]=this.waiting[oid];delete this.waiting[oid];console.debug(`${this.id} post-swap:`,this.waiting)}
return tile}}
return this.latest}
determineWhichPairTileToThrow(had,received){if(this.tracker.get(had.getTileFace())===0)return had;if(this.tracker.get(received.getTileFace())===0)return received;let tiles=this.getAvailableTiles(!0).slice();let pos=tiles.indexOf(had);tiles.splice(pos,1);let suits=[0,0,0,0,0];tiles.forEach(tile=>{suits[tile.getTileSuit()]++});let hsuit=had.getTileSuit();let rsuit=received.getTileSuit();if(hsuit<3&&suits[hsuit]===0)return had;if(rsuit<3&&suits[rsuit]===0)return received;let hnum=had.getTileFace();let rnum=received.getTileFace();if(hnum>26){if(rnum>26){if(hnum>30)return received;if(hnum===27+this.wind)return received;if(hnum===27+this.windOfTheRound)return received;if(rnum>30)return had;if(rnum===27+this.wind)return had;if(rnum===27+this.windOfTheRound)return had;return received}
return received}
if(rnum>26)return had;return received}
determineDiscardCarefully(tilesRemaining,resolve,showAllSuggestions){let tiles=this.getAvailableTiles();let tileCount=[];let immediateValue=[];let faces=Array.from(tiles).map(tile=>{let id=tile.getTileFace();if(!tileCount[id]){tileCount[id]=0}
tileCount[id]++;return id});faces.forEach(tile=>{let value=0;let availability=this.tracker.get(tile);let deadScore=this.personality.deadTile(tile,tilesRemaining);if(deadScore)return(immediateValue[tile]=deadScore);if(tileCount[tile]>=3)value=max(value,availability>0?100:90);else if(tileCount[tile]===2)value=max(value,availability>0?90:50);else if(tileCount[tile]===1){if(tile<27)
value=max(value,this.determineDiscardValueForChow(value,tile,tileCount));if(tile===27+this.wind||tile===27+this.windOfTheRound||tile>30)
value=max(value,availability>0?45:0);if(tile===27+this.wind&&tile===27+this.windOfTheRound)
value=max(value,availability>0?60:0);}
immediateValue[tile]=value});let sorted=immediateValue.map((score,tile)=>({tile,score})).sort((a,b)=>{let diff=(a.score-b.score);if(diff!==0)return diff;return(a.tile-b.tile)});let lowest=sorted[0];let candidates=sorted.filter(v=>v.score===lowest.score);if(showAllSuggestions){return resolve(candidates.map(candidate=>this.getSingleTileFromHand(candidate.tile)))}
let idx=Math.floor(config.PRNG.nextFloat()*candidates.length);let candidate=candidates[idx].tile;resolve(this.getSingleTileFromHand(candidate))}
determineDiscardValueForChow(value,tile,tileCount){let face=tile%9;let m2=face>1&&tileCount[tile-2];let m1=face>0&&tileCount[tile-1];let p1=face<8&&tileCount[tile+1];let p2=face<7&&tileCount[tile+2];let m2a=this.tracker.get(tile-2);let m1a=this.tracker.get(tile-1);let p1a=this.tracker.get(tile+1);let p2a=this.tracker.get(tile+2);if(face<7){if(p1&&p2)value=max(value,90);else if(p1&&p2a)value=max(value,80);else if(p1a&&p2)value=max(value,70);}
if(face>0&&face<8){if(m1&&p1)value=max(value,90);else if(m1&&p1a)value=max(value,80);else if(m1a&&p1)value=max(value,80);}
if(face>1){if(m2&&m1)value=max(value,90);else if(m2&&m1a)value=max(value,70);else if(m2a&&m1)value=max(value,80);}
if(value===0){for(let i=3,c1,c2;i<=8;i++){c1=tileCount[tile-i]&&((tile-i)%9<face);c2=tileCount[tile+i]&&((tile+i)%9>face);if(c1||c2)return 8-i}}
return value}
async determineClaim(pid,discard,tilesRemaining,resolve,interrupt,claimTimer){let ignore={claimtype:CLAIM$1.IGNORE};let tile=discard.getTileFace();let mayChow=this.mayChow(pid);let tiles=this.getTileFaces();tiles.sort();let{lookout,waiting}=this.tilesNeeded();if(waiting){let winTiles={};lookout.forEach((list,tileNumber)=>{if(list){list=list.filter(v=>v.indexOf('32')===0);if(list.length)winTiles[tileNumber]=list}});this.markWaiting(winTiles);console.debug(this.id,'waiting to win',winTiles,this.getTileFaces(),this.getLockedTileFaces(),'tile',tile,'in list?',winTiles[tile]);let ways=winTiles[tile]||[];if(!ways.length){if(lookout[tile]&&lookout[tile].indexOf('16')!==-1){let allowed=this.personality.want(tile,CLAIM$1.KONG,tilesRemaining);console.debug(`${this.id} wants to claim a kong ${tile} - allowed by policy? ${allowed}`);if(allowed)return resolve({claimtype:CLAIM$1.KONG})}
resolve(ignore)}else{let wintype=ways.map(v=>parseInt(v.substring(3))).sort((a,b)=>(b-a))[0];let allowed=this.personality.determineWhetherToWin(tile,wintype,tilesRemaining);if(allowed===!1)return resolve(ignore);if(allowed===wintype){if(CLAIM$1.CHOW<=allowed&&allowed<CLAIM$1.PUNG&&!mayChow){return resolve(ignore)}
return resolve({claimtype:allowed})}
return resolve({claimtype:CLAIM$1.WIN,wintype})}}
if(lookout[tile]){let claims=lookout[tile].map(print=>unhash$1(print,tile)).map(set=>{let type=set.type;console.debug(`lookout for ${tile} = type: ${type}, mayChow: ${mayChow}`);if(type===Constants.CHOW1||type===Constants.CHOW2||type===Constants.CHOW3){if(!mayChow)return}
if(!this.personality.want(tile,type,tilesRemaining))return!1;if(type===CLAIM$1.WIN)wintype=set.subtype?set.subtype:'normal';return{claimtype:type}});claims=claims.filter(v=>v).sort((a,b)=>(b.claimtype-a.claimtype));if(!claims.length)return resolve(ignore);return resolve(claims[0])}
return resolve(ignore)}
async checkKong(){if(this.ui&&!config.BOT_PLAY)return!1;let tiles=this.getTileFaces();let counts=new Array(34).fill(0);tiles.forEach(t=>counts[t]++);for(let tile=0,e=34,count;tile<e;tile++){count=counts[tile];if(count===4){let tiles=this.tiles.filter(t=>t.getTileFace()==tile);this.lockClaim(tiles);return tiles}}
return!1}
robKong(pid,tiles,tilesRemaining,resolve){let{lookout,waiting}=this.tilesNeeded();if(waiting){let tile=tiles[0].getTileFace();let need=lookout[tile];if(need&&need.some(v=>v.indexOf('32')===0)){let reasons=need.filter(v=>v.indexOf('32')===0).map(v=>parseInt(v.replace('32s','')));if(reasons.length>0){let reason=reasons[0];if(reasons.length>1){reasons.sort((a,b)=>(a-b));reason=reasons[0];if(reason>=CLAIM$1.CHOW&&reason<=CLAIM$1.PUNG){if(reasons.indexOf(CLAIM$1.PUNG)>0){let chows=!0;let pungs=!0;this.locked.forEach(set=>{if(set[0].getTileFace()!==set[1].getTileFace())pungs=!1;else chows=!1});if(chows&&!pungs){reason=reasons[0]}
if(!chows&&pungs){reason=CLAIM$1.PUNG}
if(!chows&&!pungs){reason=CLAIM$1.PUNG}}}}
if(this.personality.determineWhetherToWin(tile,reason,tilesRemaining))return resolve({claimtype:CLAIM$1.WIN,wintype:reason,from:pid,tile:tile,by:this.id})}}}
resolve()}}
const filenames={thud:[`play-01.mp3`,`play-02.mp3`,`play-03.mp3`,`play-04.mp3`,`play-05.mp3`,`play-06.mp3`,`play-07.mp3`,],click:[`click-01.mp3`,`click-02.mp3`,`click-03.mp3`,`click2-01.mp3`,`click2-02.mp3`,],multi:[`click-multi-01.mp3`,`click-multi-02.mp3`,`click-multi-03.mp3`],kong:[`click-multi-large-01.mp3`,`click-multi-large-02.mp3`],start:[`start.mp3`],win:[`win.mp3`],draw:[`draw.mp3`],end:[`end.mp3`],};const buildBin=(filename)=>{let audio=document.createElement("audio");audio.src=`../audio/${filename}`;audio.type=`mp3`;return audio};const clips={};Object.keys(filenames).forEach((bin)=>(clips[bin]=filenames[bin].map(buildBin)));function playClip(name,id){if(!config.USE_SOUND)return;let bin=clips[name];if(!bin){return console.error(`audio bin ${name} does not exist`)}
let pos=random(bin.length);let audio=bin[pos];if(!audio){return console.error(`audio bin ${name} does not have a clip ${pos}`)}
audio.cloneNode().play()}
const rotateWinds=(function generateRotateWindsFunction(){const winds=Array.from(document.querySelectorAll('.player-wind'));const indicator=document.querySelector('.windicator');const handcount=indicator.querySelector('.hand-counter');let previous=0;function rotateWinds(rules,wind=!1,wotr=!1,hand='',draws=''){handcount.innerHTML=`round ${1+wotr}<br>hand ${hand}`;if(draws){handcount.innerHTML+=`<br>rtr ${draws}`}
let h=(wotr*4+wind);if(h===previous)return;previous=h;let p=(((h/4)|0)%4);let offset=(2*p);indicator.style.setProperty('--slide',offset+'em');if(!rules)rules=globalThis.currentGame.game.rules;if(rules.reverse_wind_direction){winds.forEach(e=>{if(e.classList.contains('tc')){e.classList.remove('tc');e.classList.add('lc')}else if(e.classList.contains('rc')){e.classList.remove('rc');e.classList.add('tc')}else if(e.classList.contains('bc')){e.classList.remove('bc');e.classList.add('rc')}else if(e.classList.contains('lc')){e.classList.remove('lc');e.classList.add('bc')}})}else{winds.forEach(e=>{if(e.classList.contains('tc')){e.classList.remove('tc');e.classList.add('rc')}else if(e.classList.contains('rc')){e.classList.remove('rc');e.classList.add('bc')}else if(e.classList.contains('bc')){e.classList.remove('bc');e.classList.add('lc')}else if(e.classList.contains('lc')){e.classList.remove('lc');e.classList.add('tc')}})}}
rotateWinds.reset=function(){previous=0;indicator.style.setProperty('--slide','0em');winds[0].setAttribute('class','player-wind tc e');winds[1].setAttribute('class','player-wind rc');winds[2].setAttribute('class','player-wind bc');winds[3].setAttribute('class','player-wind lc');indicator.classList.remove('done')};rotateWinds.done=function(){return(indicator.classList.add('done'))};return rotateWinds})();class ClientUIMaster{constructor(player,tracker){this.player=player;this.tracker=tracker;this.tracker.setUI(this);this.id=player.id;this.discards=document.querySelector(`.discards`);this.playerbanks=document.querySelectorAll(`.player`);this.knowledge=document.querySelector(`.knowledge`);this.settings=document.querySelector(`.settings`);this.gameBoard=document.querySelector(`.board`);if(config.PAUSE_ON_BLUR){this.gameBoard.addEventListener(`blur`,async(evt)=>{if(!this.player.game)this.player.game=globalThis.currentGame.game;let resume=await this.player.game.pause();let handleResume=()=>{this.gameBoard.removeEventListener(`focus`,handleResume);resume();this.pause_protection=!0};this.gameBoard.addEventListener(`focus`,handleResume)})}
this.settings.addEventListener(`click`,()=>modal.pickPlaySettings());this.el=this.playerbanks[this.id];this.reset(0,0);if(config.FORCE_OPEN_BOT_PLAY){globalThis.PLAYER_BANKS=this.playerbanks;globalThis.PLAYER_BANKS.sortTiles=e=>this.sortTiles(e)}}
reset(wind,windOfTheRound,hand,draws){if(!this.el)return;this.el.setAttribute(`class`,`player`);this.playerbanks.forEach(b=>{b.innerHTML=``;b.setAttribute(`class`,`player`)});this.el.innerHTML=``;let discards=this.discards;discards.innerHTML=``;discards.setAttribute(`class`,`discards`);this.bar=document.createElement(`div`);this.bar.classList.add(`countdown-bar`);this.discards.appendChild(this.bar);if(this.countdownTimer)this.countdownTimer.cancel();this.countdownTimer=!1;rotateWinds(this.rules,wind,windOfTheRound,hand,draws)}
resetTracker(tiles){if(!this.knowledge)return;this.knowledge.innerHTML=``;Object.keys(tiles).forEach(tile=>{let div=document.createElement(`div`);div.classList.add(`tile-count`);if(tile>33)div.classList.add(`hidden`);for(let i=0;i<4;i++){let e=create(tile);div.appendChild(e)}
this.knowledge.appendChild(div)})}
reduceTracker(tileNumber){if(tileNumber>33)return;let tile=this.knowledge.querySelector(`game-tile[tile='${tileNumber}']`);if(tile)tile.remove();}
setRules(rules){this.rules=rules}
pause(lock){this.paused=lock;if(this.countdownTimer){this.countdownTimer.pause()}
if(modal.isHidden()){this.discards.classList.add(`paused`)}}
resume(){this.discards.classList.remove(`paused`);if(this.countdownTimer){this.countdownTimer.resume()}
this.paused=!1}
setClaimTimerCleanup(fn){this.claimCleanup=fn}
startCountDown(ms){document.querySelector(".corner.settings").style.visibility="hidden";new TaskTimer(timer=>{this.countdownTimer=timer},()=>{this.countdownTimer=!1},ms,(count)=>{let fraction=count===10?1:count/10;this.bar.style.width=`${100 - 100 * fraction}%`;if(fraction===1){this.bar.classList.remove(`active`);this.countdownTimer=!1;if(this.claimCleanup)this.claimCleanup();this.claimCleanup=!1}},10);this.bar.classList.add(`active`)}
gameWillStart(){rotateWinds.reset();playClip(`start`);this.playerbanks.forEach(b=>{if(this.rules)b.dataset.score=Game.getPaddedDataScore(this.rules.player_start_score);b.dataset.wins=0})}
handWillStart(redraw,resolve){if(config.BOT_PLAY)return resolve();let heading=`Ready to start playing?`;if(redraw)heading=`Ready to replay hand?`;modal.choiceInput(heading,[{label:`ready!`,value:!1}],resolve)}
playWillStart(){}
markTilesLeft(remaining){let ui=document.querySelector(`.wall.data`);ui.textContent=`${remaining} tiles left`}
async confirmKong(tile,resolve){if(config.BOT_PLAY)return resolve(!0);let cancel=()=>resolve(!1);modal.choiceInput(`Declare kong (${config.TILE_NAMES[tile]})?`,[{label:`Absolutely`,value:`yes`},{label:`No, I have plans for those tiles`,value:`no`},],result=>{if(result===`yes`)resolve(!0);else resolve(!1)},cancel)}
removeLastDiscard(){if(this.discards.lastChild){this.player.game.discards.pop();this.discards.removeChild(this.discards.lastChild)}}
nextPlayer(){this.discards.lastChild.unmark(`selectable`)}
haveSingle(tile){let tiles=this.getAllTilesInHand(tile.dataset?tile.getTileFace():tile);return tiles.length>=1}
canPung(tile){let tiles=this.getAllTilesInHand(tile.dataset?tile.getTileFace():tile);return tiles.length>=2}
canKong(tile){let tiles=this.getAllTilesInHand(tile.dataset?tile.getTileFace():tile);return tiles.length===3}
canChow(tile,type){tile=(tile.dataset?tile.getTileFace():tile);if(tile>26)return!1;let face=tile%9;let t1,t2;if(type===CLAIM$1.CHOW1){if(face>6)return!1;t1=tile+1;t2=tile+2}
if(type===CLAIM$1.CHOW2){if(face===0||face===8)return!1;t1=tile-1;t2=tile+1}
if(type===CLAIM$1.CHOW3){if(face<2)return!1;t1=tile-2;t2=tile-1}
return this.getSingleTileFromHand(t1)&&this.getSingleTileFromHand(t2)}
endOfHand(disclosure,force_reveal_player=!1){this.player.game.discards=[];if(!disclosure){playClip(`draw`);this.discards.classList.add(`exhausted`);return}
if(!force_reveal_player)playClip(`win`);disclosure.forEach((res,id)=>{if(id==this.id&&!force_reveal_player)return;let bank=this.playerbanks[id];bank.innerHTML=``;bank.setAttribute(`class`,`player`);res.bonus.forEach(t=>{t=create(t);t.bonus();bank.appendChild(t)});let locknum=1+this.getLockedTiles(bank).length;res.locked.forEach(s=>{s.forEach(t=>{let n=create(t.getTileFace());n.lock(locknum);if(t.isWinningTile())n.winning();bank.appendChild(n)});locknum+=s.length});res.concealed.sort((a,b)=>(a-b)).forEach(t=>bank.appendChild(create(t)));if(res.winner){this.discards.classList.add(`winner`);bank.classList.add(`winner`)}
bank.dataset.wincount=res.wincount;this.sortTiles(bank)})}
endOfGame(scores){rotateWinds.done();playClip(`end`);let v=0,b=-1;scores.forEach((score,id)=>{if(score>v){v=score;b=id}});this.playerbanks.forEach((bank,id)=>{bank.classList.remove(`waiting`);bank.classList.remove(`winner`);if(id===b)bank.classList.add(`game-winner`);});let remove=[];this.playerbanks.forEach(bank=>{remove=[...remove,...bank.querySelectorAll(`game-tile`)]});remove=[...remove,...this.discards.querySelectorAll(`game-tile`)];remove.forEach(t=>t.parentNode.removeChild(t));this.playerbanks.forEach(bank=>{new Array(13).fill(-1).forEach(t=>bank.appendChild(create(t)))});this.tracker.reset()}
recordScores(scores){scores.forEach((score,b)=>{let d=this.playerbanks[b].dataset;let scoreUnpadded=d.score.replace(/\D/g,'');if(!scoreUnpadded)d.score=Game.getPaddedDataScore(0);d.score=Game.getPaddedDataScore(parseInt(scoreUnpadded)+score)})}
loadHandPostGame(disclosure){this.endOfHand(disclosure,!0)}
markHand(hand,wind){this.el.dataset.wind=[`東`,`南`,`西`,`北`][wind]}
activate(id){this.playerbanks.forEach(bank=>bank.classList.remove(`active`));this.playerbanks[id].classList.add(`active`);if(id!=this.id){let latest=this.el.querySelector(`game-tile.latest`);if(latest)latest.unmark(`latest`);}}
disable(){this.el.classList.remove(`active`)}
markWaiting(val){if(val)this.el.classList.add(`waiting`);else this.el.classList.remove(`waiting`)}
markWinner(wincount){this.el.dataset.wincount=wincount;this.el.classList.add(`winner`);this.el.classList.remove(`active`)}
append(t){let old=this.el.querySelector(`game-tile.latest`);if(old){old.unmark(`latest`);old.setTitle(``)}
if(!t.isLocked()){t.mark(`latest`);t.setTitle(`latest tile`)}
this.el.appendChild(t);this.sortTiles()}
remove(tile){try{this.el.removeChild(tile)}catch(_){}}
lockClaim(tiles){playClip(tiles.length===4?`kong`:`multi`);this.removeLastDiscard();let locknum=1+this.getLockedTiles().length;tiles.forEach(tile=>{tile.lock(locknum);this.append(tile)});this.sortTiles()}
meldKong(tile){let other=this.el.querySelector(`game-tile[locked][tile='${tile.getTileFace()}']`);tile.lock(other.getLockNumber());this.el.appendChild(tile);this.sortTiles()}
playerDiscarded(player,tile,playcounter){playClip(playcounter===1?`thud`:`click`);let bank=this.playerbanks[player.id];console.debug(`${this.id} sees discard ${tile} from ${player.id}`);if(player.id!=this.id){let blank=bank.querySelector(`[tile='-1']`);if(blank)bank.removeChild(blank);}
let discard=create(tile);discard.mark(`discard`);discard.setFrom(player.id);this.discards.appendChild(discard);let canClaim=!1;let suit=((tile/9)|0);let{lookout}=this.player.tilesNeeded();let types=lookout[tile];let mayChow=this.player.mayChow(player.id);if(types){for(let type of types){if(CLAIM$1.CHOW<=type&&type<CLAIM$1.PUNG&&!mayChow)continue
canClaim=!0}}
if(!canClaim&&mayChow&&tile<27&&this.getSingleTileFromHand(tile)){let
n1=tile<26&&this.getSingleTileFromHand(tile+1),sn1=(((tile+1)/9)|0),n2=tile<25&&this.getSingleTileFromHand(tile+2),sn2=(((tile+2)/9)|0),p2=tile>1&&this.getSingleTileFromHand(tile-2),sp2=(((tile-2)/9)|0),p1=tile>0&&this.getSingleTileFromHand(tile-1),sp1=(((tile-1)/9)|0),c1=n2&&n1&&sn2===suit&&sn1===suit,c2=n1&&p1&&sn1===suit&&sp1===suit,c3=p2&&p1&&sp2===suit&&sp1===suit;if(c1||c2||c3)canClaim=!0}
if(!config.BOT_PLAY&&(canClaim||!config.AUTO_SKIP_DISCARDS)&&player.id!==this.id){this.startCountDown(config.CLAIM_INTERVAL)}
if(config.AUTO_SKIP_DISCARDS&&player.id!==this.id&&!canClaim){document.querySelector(".corner.settings").style.visibility="hidden";setTimeout(()=>document.querySelector(".discards").click(),500)}
this.sortTiles(bank)}
see(tiles,player){console.debug(`${this.id} sees ${tiles.map(t => t.dataset ? t.getTileFace() : t)} from ${player.id}`);let bank=this.playerbanks[player.id];let locknum=1+bank.querySelectorAll(`[locked]`).length;tiles.forEach(tile=>{let face=(tile.dataset?tile.getTileFace():tile);if(player.id!=this.id){let blank=bank.querySelector(`[tile='-1']`);if(blank)bank.removeChild(blank);}
let e=create(face);if(tile.isHidden&&tile.isHidden())e.hide();e.lock(locknum);bank.appendChild(e)});this.sortTiles(bank)}
seeClaim(tiles,player,claim){playClip(tiles.length===4?`kong`:`multi`);let bank=this.playerbanks[player.id];let blank=create(-1);bank.appendChild(blank);this.removeLastDiscard();this.see(tiles,player);if(!config.BOT_PLAY){this.renderClaimAnnouncement(player.id,claim.claimtype)}}
playerGaveUpKongTile(pid,tilenumber){let bank=this.playerbanks[pid];let tile=bank.querySelector(`game-tile[locked][tile='${tilenumber}']`);tile.remove()}
renderClaimAnnouncement(pid,claimtype){let label=`win`;if(claimtype===16)label=`kong`;if(claimtype===8)label=`pung`;if(claimtype<8)label=`chow`;let ann=document.createElement(`div`);ann.classList.add(`announcement`);ann.textContent=`${label}!`;ann.dataset.player=pid;let parent=document.querySelector(`.board`);parent.appendChild(ann);setTimeout(()=>ann.parentNode.removeChild(ann),2300)}
receivedTile(player){if(player.id===this.id)return;let bank=this.playerbanks[player.id];bank.append(create(-1));this.sortTiles(bank)}
sortTiles(bank){bank=(bank||this.el);Array.from(bank.querySelectorAll(`game-tile`)).sort(this.tilebank_sort_function).forEach(tile=>bank.appendChild(tile))}
getLockedTiles(bank){return(bank||this.el).querySelectorAll(`game-tile[locked]`)}
getAvailableTiles(){return this.el.querySelectorAll(`game-tile:not([bonus]):not([locked])`)}
getSingleTileFromHand(tileNumber){return this.el.querySelector(`game-tile[tile='${tileNumber}']:not([locked])`)}
getAllTilesInHand(tileNumber){return this.el.querySelectorAll(`game-tile[tile='${tileNumber}']:not([locked])`)}
getTiles(allTiles){return this.el.querySelectorAll(`game-tile${allTiles ? ``: `:not([locked])`}`)}
getTileFaces(allTiles){return Array.from(this.getTiles(allTiles)).map(t=>t.getTileFace())}
tilebank_sort_function(a,b){try{let la=a.getLockNumber();let lb=b.getLockNumber();a=a.getTileFace();b=b.getTileFace();if(a>33||b>33){if(a>33&&b>33)return a-b;if(a>33)return-1;return 1}
if(la||lb){if(la&&lb)return(la===lb)?a-b:la-lb;if(la)return-1;return 1}
if(a===-1)return 1;if(b===-1)return-1;return a-b}catch(e){console.log(a,b);console.log(a.constructor.name,b.constructor.name);throw(e)}}}
class ClientUI extends ClientUIMaster{constructor(player,tracker){super(player,tracker);this.listeners=[];this.longPressTimeout=!1}
listen(target,event,handler){this.listeners.push({target,event,handler});let opts={};if(event.indexOf('touch')!==-1)opts.passive=!0;target.addEventListener(event,handler,opts)}
removeListeners(target,event){let removals=this.listeners.filter(data=>(data.target===target&&data.event===event));removals.forEach(data=>{let opts={};if(data.event.indexOf('touch')!==-1)opts.passive=!0;data.target.removeEventListener(data.event,data.handler,opts)});this.listeners=this.listeners.filter(data=>(data.target!==target||data.event!==event));return()=>removals.forEach(data=>this.listen(data.target,data.event,data.handler))}
removeAllListeners(){let removals=this.listeners;removals.forEach(data=>{let opts={};if(data.event.indexOf('touch')!==-1)opts.passive=!0;data.target.removeEventListener(data.event,data.handler,opts)});this.listeners=[];return()=>removals.forEach(data=>this.listen(data.target,data.event,data.handler))}
pause(lock){super.pause(lock);if(this.claimTimer)this.claimTimer.pause();}
resume(){super.resume();if(this.claimTimer)this.claimTimer.resume();}
listenForDiscard(resolve,suggestions,lastClaim,winbypass){let tiles=this.getAvailableTiles();let currentTile=this.currentTile=this.player.latest;let curid=currentTile?Array.from(tiles).indexOf(currentTile):0;if(curid===-1)curid=0;this.markCurrentTile(curid);this.highlightBotSuggestions(suggestions);if(tiles.length===0)return resolve(undefined);if(lastClaim&&lastClaim.claimtype===CLAIM$1.WIN)return resolve(undefined);let{winner}=this.player.tilesNeeded();if(winner&&!winbypass)return this.askForWinConfirmation(resolve);tiles.forEach(tile=>tile.mark('selectable'));this.listen(document,"keydown",evt=>this.listenForDiscardFromKeys(evt,tiles,suggestions,resolve));this.listenForDiscardFromMouse(tiles,suggestions,resolve)}
listenForDiscardFromMouse(tiles,suggestions,resolve){tiles.forEach(tile=>this.addMouseEventsToTile(tile,suggestions,resolve))}
addMouseEventsToTile(tile,suggestions,resolve){this.listen(tile,"mouseover",evt=>this.highlightTile(tile));this.listen(tile,"click",evt=>this.discardCurrentHighlightedTile(suggestions,resolve));this.listen(tile,"mousedown",evt=>this.initiateLongPress(evt,suggestions,resolve));this.listen(tile,"touchstart",evt=>this.initiateLongPress(evt,suggestions,resolve))}
listenForDiscardFromKeys(evt,tiles,suggestions,resolve){let code=evt.keyCode;let willBeHandled=[VK_LEFT,VK_RIGHT,VK_UP,VK_DOWN,VK_SIGNAL,VK_START,VK_END].some(supported=>supported[code]);if(!willBeHandled)return;if(VK_SIGNAL[code]&&evt.repeat)return;evt.preventDefault();let tlen=tiles.length;let currentTile=this.currentTile;let curid=this.curid;if(VK_LEFT[code])curid=(currentTile===!1)?tlen-1:(curid===0)?tlen-1:curid-1;if(VK_RIGHT[code])curid=(currentTile===!1)?0:(curid===tlen-1)?0:curid+1;if(VK_START[code])curid=0;if(VK_END[code])curid=tlen-1;currentTile=this.markCurrentTile(curid);if(VK_UP[code]||VK_SIGNAL[code]){if(!vk_signal_lock){lock_vk_signal();this.currentTile.unmark('highlight');this.discardCurrentHighlightedTile(suggestions,resolve)}}
if(VK_DOWN[code])this.spawnDeclarationModal(suggestions,resolve);}
highlightTile(tile){let tiles=this.getAvailableTiles();let curid=Array.from(tiles).indexOf(tile);this.markCurrentTile(curid)}
markCurrentTile(curid){let tiles=this.getAvailableTiles();if(tiles.length===0)return;this.curid=curid;this.currentTile=tiles[curid];tiles.forEach(tile=>tile.unmark('highlight'));this.currentTile.mark('highlight');return this.currentTile};initiateLongPress(evt,suggestions,resolve){let releaseEvents=['mouseup','dragend','touchend'];if(evt.type==='mousedown'&&evt.which!==1)return;if(!this.longPressTimeout){this.longPressTimeout=setTimeout(()=>{releaseEvents.forEach(event=>this.removeListeners(document,event));this.cancelLongPress();let restoreClickHandling=this.removeListeners(evt.target,"click");this.spawnDeclarationModal(suggestions,resolve,restoreClickHandling)},1000)}
let cancelPress=evt=>this.cancelLongPress(evt);releaseEvents.forEach(event=>this.listen(document,event,cancelPress))};cancelLongPress(evt){if(this.longPressTimeout){this.longPressTimeout=clearTimeout(this.longPressTimeout)}}
highlightBotSuggestions(suggestions){if(config.SHOW_BOT_SUGGESTION&&suggestions){suggestions.forEach(suggestion=>{if(!suggestion)return;let suggestedTile=this.getSingleTileFromHand(suggestion.getTileFace());if(suggestedTile){suggestedTile.mark('suggestion');suggestedTile.setTitle('Bot-recommended discard.')}else{console.log(`The bot got confused and wanted you to throw out something that's not in your hand...!`);console.log(suggestion)}})}}
askForWinConfirmation(resolve){let cancel=()=>resolve(undefined);modal.choiceInput("Declare win?",[{label:'You better believe it!',value:'win'},{label:'No, I think I can do better...',value:''},],result=>{if(result){if(!this.player.lastClaim){this.player.selfdraw=!0}
resolve(undefined)}else this.listenForDiscard(resolve,undefined,undefined,!0)},cancel)}
discardCurrentHighlightedTile(suggestions=[],resolve){let tiles=this.getAvailableTiles();this.cancelLongPress();suggestions.forEach(suggestion=>{if(suggestion){suggestion.unmark('suggestion');suggestion.setTitle('')}});let latest=this.player.latestTile;if(latest)latest.unmark('latest');tiles.forEach(tile=>tile.unmark('selectable','highlight','suggestion'));this.removeAllListeners();resolve(this.currentTile)}
spawnDeclarationModal(suggestions,resolve,restore){let currentTile=this.currentTile;let face=currentTile.getTileFace();let allInHand=this.getAllTilesInHand(face);let canKong=!1;if(allInHand.length===4)canKong=!0;else if(this.player.locked.some(set=>set.every(t=>t.getTileFace()==face)))canKong=!0;let{winpaths}=this.player.tilesNeeded();let canWin=winpaths.length>0;if(!canWin){let allTiles=this.getTileFaces(!0).filter(t=>t<34);canWin=this.player.rules.checkForLimit(allTiles)}
let options=[{label:"on second thought, never mind",value:CLAIM$1.IGNORE},canKong?{label:"I'm declaring a kong",value:CLAIM$1.KONG}:!1,canWin?{label:"I just won",value:CLAIM$1.WIN}:!1].filter(v=>v);modal.choiceInput("Declare a kong or win?",options,result=>{if(result===CLAIM$1.IGNORE){if(restore)return restore();}
if(result===CLAIM$1.KONG){currentTile.exception=CLAIM$1.KONG;currentTile.kong=[...allInHand];return this.discardCurrentHighlightedTile(suggestions,resolve)}
if(result===CLAIM$1.WIN){this.currentTile=undefined;return this.discardCurrentHighlightedTile(suggestions,resolve)}})}
listenForClaim(pid,discard,suggestion,resolve,interrupt,claimTimer){let tile=this.discards.lastChild;let mayChow=this.player.mayChow(pid);this.claimTimer=claimTimer;this.setClaimTimerCleanup(()=>this.removeAllListeners());if(config.SHOW_CLAIM_SUGGESTION){this.tryClaimHighlight(pid,tile,mayChow)}
if(config.SHOW_BOT_SUGGESTION&&suggestion){if(suggestion&&suggestion.claimtype){tile.mark('suggestion')}}
this.pause_protection=!1;this.setupInputListening(tile,mayChow,interrupt,resolve)}
setupInputListening(tile,mayChow,interrupt,resolve){tile.mark('selectable');let discards=this.discards;this.listen(tile,"click",evt=>this.triggerClaimDialog(tile,mayChow,interrupt,resolve));this.listen(discards,"click",evt=>this.safelyIgnoreDicard(evt,tile,mayChow,interrupt,resolve));this.listen(discards,"mousedown",evt=>this.verifyPauseProtection());this.listen(discards,"touchstart",evt=>this.verifyPauseProtection());this.listen(document,"keydown",evt=>this.handleKeyDuringClaim(evt,tile,mayChow,interrupt,resolve))}
verifyPauseProtection(){if(this.paused){this.pause_protection=!0}};getDistanceToTile(evt,tile){let bbox=tile.getBoundingClientRect();let midpoint={x:(bbox.left+bbox.right)/2,y:(bbox.top+bbox.bottom)/2};let vector={x:midpoint.x-evt.clientX,y:midpoint.y-evt.clientY};return Math.sqrt(vector.x**2+vector.y**2)}
registerUIInput(interrupt){if(this.countdownTimer)this.countdownTimer.cancel();interrupt()}
handleKeyDuringClaim(evt,tile,mayChow,interrupt,resolve){if(vk_signal_lock)return;let code=evt.keyCode;let willBeHandled=(VK_LEFT[code]||VK_RIGHT[code]||VK_UP[code]||VK_SIGNAL[code]);if(!willBeHandled)return;evt.preventDefault();this.removeAllListeners();if(VK_UP[code]||VK_SIGNAL[code])return this.triggerClaimDialog(tile,mayChow,interrupt,resolve);return this.ignoreDiscard(tile,interrupt,resolve)}
ignoreDiscard(tile,interrupt,resolve){this.registerUIInput(interrupt);tile.unmark('highlight');tile.unmark('suggestion');tile.unmark('selectable');this.removeAllListeners();resolve({claimtype:CLAIM$1.IGNORE})}
safelyIgnoreDicard(evt,tile,mayChow,interrupt,resolve){if(this.pause_protection){return(this.pause_protection=!1)}
if(this.getDistanceToTile(evt,tile)>40){return this.ignoreDiscard(tile,interrupt,resolve)}
this.triggerClaimDialog(tile,mayChow,interrupt,resolve)}
tryClaimHighlight(pid,tile,mayChow){let face=tile.getTileFace();let suit=((face/9)|0);let{lookout}=this.player.tilesNeeded();let types=lookout[face];if(types){for(let type of types){if(CLAIM$1.CHOW<=type&&type<CLAIM$1.PUNG&&!mayChow)continue
return tile.mark('highlight');}}
this.tryChowHighlight(tile,mayChow,face,suit)}
tryChowHighlight(tile,mayChow,face,suit){if(mayChow&&face<27&&this.getSingleTileFromHand(face)){let
n1=face<26&&this.getSingleTileFromHand(face+1),sn1=(((face+1)/9)|0),n2=face<25&&this.getSingleTileFromHand(face+2),sn2=(((face+2)/9)|0),p2=face>1&&this.getSingleTileFromHand(face-2),sp2=(((face-2)/9)|0),p1=face>0&&this.getSingleTileFromHand(face-1),sp1=(((face-1)/9)|0),c1=n2&&n1&&sn2===suit&&sn1===suit,c2=n1&&p1&&sn1===suit&&sp1===suit,c3=p2&&p1&&sp2===suit&&sp1===suit;if(c1||c2||c3)tile.mark("highlight");}}
triggerClaimDialog(tile,mayChow,interrupt,resolve){this.registerUIInput(interrupt);this.removeAllListeners();let cancel=()=>this.ignoreDiscard(tile,interrupt,resolve);let{lookout}=this.player.tilesNeeded();let claimList=lookout[tile.getTileFace()];let mayWin=claimList&&claimList.some(type=>parseInt(type)===CLAIM$1.WIN);console.debug(this.player.id,tile,mayChow,this,this.canPung(tile));modal.choiceInput("What kind of claim are you making?",[{label:"Ignore",value:CLAIM$1.IGNORE},(mayChow&&this.canChow(tile,CLAIM$1.CHOW1))?{label:"Chow (▮▯▯)",value:CLAIM$1.CHOW1}:!1,(mayChow&&this.canChow(tile,CLAIM$1.CHOW2))?{label:"Chow (▯▮▯)",value:CLAIM$1.CHOW2}:!1,(mayChow&&this.canChow(tile,CLAIM$1.CHOW3))?{label:"Chow (▯▯▮)",value:CLAIM$1.CHOW3}:!1,this.canPung(tile)?{label:"Pung",value:CLAIM$1.PUNG}:!1,this.canKong(tile)?{label:"Kong",value:CLAIM$1.KONG}:!1,mayWin?{label:"Win",value:CLAIM$1.WIN}:!1,],result=>{tile.unmark('highlight');tile.unmark('suggestion');tile.unmark('selectable');this.removeAllListeners();if(result===CLAIM$1.WIN)return this.spawnWinDialog(tile,claimList,resolve,cancel);resolve({claimtype:result})},cancel)}
spawnKongRobDialog(pid,tiles,tilesRemaining,suggestions,resolve){let tile=tiles[0].getTileFace();let claim=!1;if(suggestions&&suggestions[0])claim=suggestions[0];else{(()=>{let{lookout,waiting}=this.player.tilesNeeded();if(!waiting)return;let need=lookout[tile];if(!need)return;let reasons=need.filter(v=>v.indexOf('32')!==0);if(reasons.length===0)return;claim={from:pid,tile:tile,claimtype:CLAIM$1.WIN,wintype:(reasons[0]|0),}})()}
if(!claim)return resolve();modal.choiceInput("Win by robbing a kong?",[{label:'You better believe it!',value:'win'},{label:'No, I think I can do better...',value:''},],result=>{if(result)return resolve(claim);resolve()},()=>resolve())}
spawnWinDialog(discard,claimList,resolve,cancel){let winOptions={pair:!1,chow:!1,pung:!1};claimList.forEach(type=>{if(parseInt(type)===CLAIM$1.WIN){let subtype=parseInt(type.split('s')[1]);if(subtype===CLAIM$1.PAIR)winOptions.pair=!0;if(subtype>=CLAIM$1.CHOW&&subtype<CLAIM$1.PUNG)winOptions.chow=!0;if(subtype>=CLAIM$1.PUNG)winOptions.pung=!0}});let options=[winOptions.pair?{label:"Pair",value:CLAIM$1.PAIR}:!1,winOptions.chow&&this.canChow(discard,CLAIM$1.CHOW1)?{label:"Chow (▮▯▯)",value:CLAIM$1.CHOW1}:!1,winOptions.chow&&this.canChow(discard,CLAIM$1.CHOW2)?{label:"Chow (▯▮▯)",value:CLAIM$1.CHOW2}:!1,winOptions.chow&&this.canChow(discard,CLAIM$1.CHOW3)?{label:"Chow (▯▯▮)",value:CLAIM$1.CHOW3}:!1,winOptions.pung?{label:"Pung",value:CLAIM$1.PUNG}:!1];modal.choiceInput("How does this tile make you win?",options,result=>{resolve({claimtype:CLAIM$1.WIN,wintype:result})},cancel)}}
class HumanPlayer extends BotPlayer{constructor(id,chicken=!1,withUi=!0){super(id,chicken);if(withUi)this.ui=new ClientUI(this,this.tracker);}
determineDiscard(tilesRemaining,resolve){const giveAllSuggestions=!0;super.determineDiscard(tilesRemaining,suggestion=>{if(config.BOT_PLAY)return resolve((suggestion&&suggestion.length)?suggestion[0]:suggestion);if(suggestion&&!suggestion.length)suggestion=[suggestion];this.ui.listenForDiscard(discard=>{if(discard)this.selfdraw=!1;if(discard&&discard.exception===CLAIM$1.KONG){let kong=discard.kong;if(kong.length===4)this.lockClaim(kong,!0);else this.meldKong(kong[0])}
resolve(discard)},suggestion,this.lastClaim)},giveAllSuggestions)}
determineClaim(pid,discard,tilesRemaining,resolve,interrupt,claimTimer){super.determineClaim(pid,discard,tilesRemaining,suggestion=>{if(config.BOT_PLAY)return resolve(suggestion);this.ui.listenForClaim(pid,discard,suggestion,resolve,interrupt,claimTimer)})}
robKong(pid,tiles,tilesRemaining,resolve){super.robKong(pid,tiles,tilesRemaining,suggestion=>{if(config.BOT_PLAY)return resolve(suggestion);this.ui.spawnKongRobDialog(pid,tiles,tilesRemaining,suggestion,resolve)})}}
let base=[...new Array(34)].map((_,i)=>i);const BASE=base.concat(base).concat(base).concat(base).concat([34,35,36,37,38,39,40,41]);class Wall{constructor(players,wallObj=null){this.players=players;if(wallObj){this.dead=wallObj.dead;this.deadSize=wallObj.deadSize;this.remaining=wallObj.remaining;this.tiles=wallObj.tiles}else this.reset()}
getBase(){return BASE.slice()}
shuffle(list){list=list.slice();let shuffled=[];while(list.length){let pos=(config.PRNG.nextFloat()*list.length)|0;shuffled.push(list.splice(pos,1)[0])}
return shuffled}
reset(){this.tiles=this.shuffle(this.getBase());this.deadSize=16;this.dead=!1;this.remaining=this.tiles.length-this.dead;if(config.WALL_HACK){WallHack.set(this,WallHack.hacks[config.WALL_HACK])}}
get(howMany=1){let left=this.tiles.length-howMany;this.remaining=left-this.deadSize;this.players.forEach((p)=>p.markTilesLeft(this.remaining));this.dead=this.tiles.length-howMany<=this.deadSize;if(howMany===1)return this.tiles.shift();return this.tiles.splice(0,howMany)}}
class Game{constructor(players,gameObj=null){this.players=players;this.discards=gameObj?gameObj.discards:[];this.wall=gameObj?gameObj.wall:new Wall(players);this.scoreHistory=gameObj?gameObj.scoreHistory:[];this._playLock=gameObj?gameObj._playLock:!1;this.GAME_START=gameObj?gameObj.GAME_START:!1;if(gameObj){this.PLAY_START=gameObj.PLAY_START;this.counter=gameObj.counter;this.currentPlayerId=gameObj.currentPlayerId;this.currentpid=gameObj.currentpid;this.discard=gameObj.discard;this.draws=gameObj.draws;this.hand=gameObj.hand;this.playDelay=gameObj.playDelay;this.rules=gameObj.rules;this.totalDraws=gameObj.totalDraws;this.totalPlays=gameObj.totalPlays;this.wind=gameObj.wind;this.windOfTheRound=gameObj.windOfTheRound}
this.resume=()=>{}}
static getPaddedDataScore(score){var scoreStr=score.toString();var len=scoreStr.length;if(len===4)return scoreStr;var pad="‏‏‎ ‎".repeat(2*(4-len));return pad+scoreStr}
async startGame(whenDone,isResuming=!1){document.body.classList.remove(`finished`);this.finish=whenDone;this.fixValues=()=>{};if(isResuming){this.play(null,isResuming)}else{this.GAME_START=Date.now();this.currentpid=0;this.wind=0;this.windOfTheRound=0;this.hand=0;this.draws=0;this.totalDraws=0;this.totalPlays=0;this.rules=Ruleset.getRuleset(config.RULES);let players=this.players;for(var i=0;i<4;i++){document.getElementById(i).setAttribute("data-score",Game.getPaddedDataScore(this.rules.player_start_score))}
await players.asyncAll(p=>p.gameWillStart(this,this.rules));config.log(`starting game.`);this.startHand()}}
async pause(){if(!this.GAME_START)return;console.debug('pausing game');let players=this.players;this._playLock=new Promise(resolve=>{this.resume=async()=>{console.debug('resuming game');this._playLock=!1;await players.asyncAll(p=>p.resume());resolve()}});await players.asyncAll(p=>p.pause(this._playLock));return this.resume}
async continue(where='unknown'){if(this._playLock){console.debug(`paused at ${where}`);await this._playLock}}
async startHand(result={}){await this.continue();let players=this.players;if(result.winner){let winner=result.winner;if(this.rules.pass_on_east_win||winner.wind!==0){let windWas=this.wind;this.wind=(this.wind+(this.rules.reverse_wind_direction?3:1))%4;if(windWas===(this.rules.reverse_wind_direction?1:3)){this.wind=0;this.windOfTheRound++;if(this.windOfTheRound===4){let ms=(Date.now()-this.GAME_START);let s=((ms/10)|0)/100;let finalScores=players.map(p=>p.getScore());let highest=finalScores.reduce((t,v)=>v>t?v:t,0);let gamewinner=finalScores.indexOf(highest);console.log(`\nfull game played: player ${gamewinner} is the winner!`);console.log(`(game took ${s}s. ${this.totalPlays} plays: ${this.hand} hands, ${this.totalDraws} draws)`);await players.asyncAll(p=>p.endOfGame(finalScores));return this.finish(s)}}}else console.debug(`Winner player was East, winds will not rotate.`)}
this.totalPlays++;if(!result.draw&&!config.FORCE_DRAW){this.hand++;this.draws=0}else{config.log(`Hand was a draw.`);this.draws++;this.totalDraws++}
await players.asyncAll(p=>{let offset=parseInt(p.id);let playerwind=(this.wind+offset)%4;if(this.rules.reverse_wind_direction){playerwind=(4+this.wind-offset)%4}
p.reset(playerwind,this.windOfTheRound,this.hand,this.draws)});if(config.PAUSE_ON_HAND&&this.hand===config.PAUSE_ON_HAND){config.HAND_INTERVAL=60*60*1000}
let pre=result.draw?'Res':'S';let logNotice=`${pre}tarting hand ${this.hand}.`;let style=`color: red; font-weight: bold; font-size: 120%; border-bottom: 1px solid black;`;config.log(`\n${logNotice}`);if(this.fixValues){this.fixValues();this.fixValues=()=>{}}
logNotice=`this.hand=${this.hand}; this.draws=${this.draws}; config.PRNG.seed(${config.PRNG.seed()}); this.wind=${this.wind}; this.windOfTheRound=${this.windOfTheRound};`;config.log(logNotice);this.wall.reset();logNotice=`wall: ${this.wall.tiles}`;console.debug(logNotice);config.log(logNotice);config.log(`initial deal`);await this.dealTiles();players.forEach(p=>{let message=`tiles for ${p.id}: ${p.getTileFaces()}`;console.debug(message);config.log(message)});config.log(`prepare play`);await this.preparePlay(config.FORCE_DRAW||this.draws>0);players.forEach(p=>{let message=`tiles for ${p.id}: ${p.getTileFaces()} [${p.getLockedTileFaces()}]`;console.debug(message);config.log(message)});await players.asyncAll(p=>p.playWillStart());this.PLAY_START=Date.now();this.play()}
async dealTiles(){await this.continue("dealTiles");let wall=this.wall;let players=this.players;let runDeal=async(player,done)=>{let bank=wall.get(13);for(let t=0,tile;t<bank.length;t++){tile=bank[t];await players.asyncAll(p=>p.receivedTile(player));let revealed=player.append(tile);if(revealed){await players.asyncAll(p=>p.see(revealed,player));bank.push(wall.get())}}
done()};return Promise.all(players.map(p=>{return new Promise(done=>runDeal(p,done))}))}
async preparePlay(redraw){await this.continue("preparePlay");this.currentPlayerId=(this.wind%4);this.discard=undefined;this.counter=0;let players=this.players;await Promise.all(players.map(p=>{return new Promise(ready=>p.handWillStart(redraw,ready))}));await Promise.all(players.map(p=>{return new Promise(done=>this.resolveKongs(p,done))}))}
serialize(circularObj){let cache=[];let result=JSON.stringify(circularObj,(key,value)=>{if(typeof value==='object'&&value!==null){if(cache.includes(value))return;cache.push(value)}
return value});cache=null;return result}
saveGameState(){let serializedGame=JSON.parse(this.serialize(globalThis.currentGame));try{serializedGame.game.discard={values:globalThis.currentGame.game.discard.values}}catch(_){serializedGame.game.discard=undefined}
serializedGame.game.rules=JSON.parse(JSON.stringify(globalThis.currentGame.game.rules));serializedGame.game.discards=[];for(let j=0;j<globalThis.currentGame.game.discards.length;j++){serializedGame.game.discards.push({values:globalThis.currentGame.game.discards[j].values})}
for(let i=0;i<globalThis.currentGame.players.length;i++){serializedGame.game.players[i].latest={values:globalThis.currentGame.players[i].latest.values};let playerDiscards=globalThis.currentGame.players[i].discards;serializedGame.game.players[i].discards=[];for(let j=0;j<playerDiscards.length;j++){serializedGame.game.players[i].discards.push({values:playerDiscards[j].values})}
let playerTiles=globalThis.currentGame.players[i].tiles;serializedGame.game.players[i].tiles=[];for(let j=0;j<playerTiles.length;j++){var values=playerTiles[j].values;serializedGame.game.players[i].tiles.push({values:values})}
let playerLocked=globalThis.currentGame.players[i].locked;serializedGame.game.players[i].locked=[];for(let j=0;j<playerLocked.length;j++){serializedGame.game.players[i].locked.push([]);for(let k=0;k<playerLocked[j].length;k++){serializedGame.game.players[i].locked[j].push({values:playerLocked[j][k].values})}}}
serializedGame.game.currentPlayerId=0;localStorage.setItem("mahjongGame",JSON.stringify(serializedGame))}
async resolveKongs(player,done){await this.continue("resolveKongs");this.players;let kong;do{kong=await player.checkKong();if(kong){await this.processKong(player,kong)}}while(kong);done()}
async processKong(player,kong,melded=!1){console.debug(`${player.id} plays kong ${kong[0].getTileFace()} (melded: ${melded})`);config.log(`${player.id} locks [${kong.map(t => t.getTileFace())}]`);let players=this.players;let robbed=await Promise.all(players.map(p=>new Promise(resolve=>p.seeKong(kong,player,this.wall.remaining,resolve))));for(let[pid,claim]of robbed.entries()){if(claim){claim.by=pid;return claim}}
let revealed=!1;do{if(player.id===0)document.querySelector(".corner.settings").style.visibility="visible";let tile=this.wall.get();config.log(`${player.id} <  ${tile} (supplement)`);revealed=player.append(tile);if(revealed){await players.asyncAll(p=>p.see(revealed,player))}}while(revealed);}
async processKongRob(claim){let pid=claim.from;let players=this.players;let tile=players[pid].giveUpKongTile(claim.tile);await players.asyncAll(p=>p.playerGaveUpKongTile(pid,claim.tile));let winner=players[claim.by];winner.robbed=!0;this.currentPlayerId=winner.id;let robbed=!0;winner.receiveDiscardForClaim(claim,tile,robbed);return this.processWin(winner,pid)}
async play(claim,resuming=!1){await this.continue("start of play()");if(resuming){let localStorageGame=JSON.parse(localStorage.getItem("mahjongGame"));let playerLatest=localStorageGame.game.players[0].latest.values.tile;if(this.players[0].tilesNeeded(playerLatest).waiting){document.getElementById("0").classList.add("waiting")}}
let hand=this.hand;let players=this.players;let wall=this.wall;if(claim)this.currentPlayerId=claim.p;let discard=this.discard;let discardpid=discard?discard.getFrom():undefined;let currentPlayerId=this.currentPlayerId;this.playDelay=(hand===config.PAUSE_ON_HAND&&this.counter===config.PAUSE_ON_PLAY)?60*60*1000:config.PLAY_INTERVAL;let player=players[currentPlayerId];await players.asyncAll(p=>p.activate(currentPlayerId));this.counter++;console.debug(`%chand ${hand}, play ${this.counter}`,`color: red; font-weight: bold;`);console.debug(`current seed: ${config.PRNG.seed()}`);if(!claim){discard=!1;discardpid=!1;let claim=await this.dealTile(player,resuming);if(claim)return this.processKongRob(claim);}else{if(player.id===0)document.querySelector(".corner.settings").style.visibility="visible";config.log(`${player.id} <  ${discard.getTileFace()} (${claim.claimtype})`);let tiles=player.receiveDiscardForClaim(claim,discard);config.log(`${player.id} has [${player.getTileFaces()}], [${player.getLockedTileFaces()}]`);await players.asyncAll(p=>p.seeClaim(tiles,player,discard,claim));if(tiles.length===4){let kong=tiles;let robbed=await Promise.all(players.map(p=>new Promise(resolve=>p.robKong(player.id,kong,this.wall.remaining,resolve))));for(let[pid,claim]of robbed.entries()){if(claim){claim.by=pid;return this.processKongRob(claim)}}
await this.dealTile(player)}}
do{if(discard)discard.unmark('discard');discard=this.discard=await new Promise(resolve=>player.getDiscard(wall.remaining,resolve));if(!discard)return this.processWin(player,discardpid);if(discard.exception===CLAIM$1.KONG){let kong=discard.kong;let melded=(kong.length===1);let claim=await this.processKong(player,kong,melded);if(claim)return this.processKongRob(claim);discard=!1}}while(!discard);await this.processDiscard(player);await this.continue("just before getAllClaims() in play()");claim=await this.getAllClaims();if(claim)return this.processClaim(player,claim);if(wall.dead){await players.asyncAll(p=>p.endOfHand());let nextHand=()=>this.startHand({draw:!0});if(!config.BOT_PLAY){return modal.choiceInput("Hand was a draw",[{label:"OK"}],nextHand,nextHand)}else return setTimeout(nextHand,this.playDelay)}
await this.continue("just before scheduling the next play() call");await players.asyncAll(p=>p.nextPlayer());this.currentPlayerId=(this.currentPlayerId+1)%4;return setTimeout(()=>{player.disable();this.play()},config.BOT_PLAY?config.BOT_PLAY_DELAY:this.playDelay)}
async dealTile(player,resuming=!1){if(resuming)return;let wall=this.wall;let revealed=!1;do{let tile=wall.get();let players=this.players;await players.asyncAll(p=>p.receivedTile(player));console.debug(`${player.id} receives ${tile} - ${player.getTileFaces()}`);config.log(`${player.id} <  ${tile} - ${player.getTileFaces()} - PRNG: ${config.PRNG.seed()}`);revealed=player.append(tile);if(revealed){await players.asyncAll(p=>p.see(revealed,player))}else{let kong=await player.checkKong(tile);if(kong){console.debug(`${player.id} plays self-drawn kong ${kong[0].getTileFace()} during play`);let claim=await this.processKong(player,kong);if(claim)return claim}}}while(revealed);if(player.id===0){document.querySelector(".corner.settings").style.visibility="visible";this.saveGameState()}}
async processWin(player,discardpid){let hand=this.hand;let players=this.players;let currentPlayerId=this.currentPlayerId;let windOfTheRound=this.windOfTheRound;player.markWinner();let play_length=(Date.now()-this.PLAY_START);let message=`Player ${currentPlayerId} wins hand ${hand}! (hand took ${play_length}ms)`;config.log(message);let fullDisclosure=players.map(p=>p.getDisclosure());console.debug('disclosure array:',fullDisclosure);await players.asyncAll(p=>p.endOfHand(fullDisclosure));console.debug("SCORING TILES");let scores=fullDisclosure.map((d,id)=>this.rules.scoreTiles(d,id,windOfTheRound,this.wall.remaining));let eastid=0;players.forEach(p=>{if(p.wind===0)eastid=p.id});let adjustments=this.rules.settleScores(scores,player.id,eastid,discardpid);await players.asyncAll(p=>{config.log(`${p.id}: ${adjustments[p.id]}, hand: ${p.getTileFaces()}, [${p.getLockedTileFaces()}], (${p.bonus}), discards: ${fullDisclosure[p.id].discards}`);p.recordScores(adjustments)});this.scoreHistory.push({fullDisclosure,scores,adjustments});scores[player.id].winner=!0;if(config.HAND_INTERVAL>0){modal.setScores(hand,this.rules,scores,adjustments,()=>{this.startHand({winner:player})})}else this.startHand({winner:player})}
async processDiscard(player){let discard=this.discard;console.debug(`${player.id} discarded ${discard.getTileFace()}`);config.log(`${player.id}  > ${discard.getTileFace()}`);player.remove(discard);discard.setFrom(player.id);discard.reveal();await this.players.asyncAll(p=>p.playerDiscarded(player,discard,this.counter))}
async getAllClaims(){await this.continue("getAllClaims");let players=this.players;let currentpid=this.currentPlayerId;let discard=this.discard;let claims=await Promise.all(players.map(p=>new Promise(resolve=>p.getClaim(currentpid,discard,this.wall.remaining,resolve))));console.debug('all claims are in');let claim=CLAIM$1.IGNORE;let win=undefined;let p=-1;claims.forEach((c,pid)=>{if(c.claimtype>claim){claim=c.claimtype;win=c.wintype?c.wintype:undefined;p=pid}});if(currentpid===0&&!config.BOT_PLAY&&config.BOT_DELAY_BEFORE_DISCARD_ENDS){await new Promise(resolve=>{setTimeout(()=>resolve(),config.BOT_DELAY_BEFORE_DISCARD_ENDS)})}
let winningClaim=(p===-1)?undefined:{claimtype:claim,wintype:win,p};return winningClaim}
processClaim(player,claim){this.discard;player.disable();setTimeout(()=>this.play(claim),config.BOT_PLAY?config.BOT_PLAY_DELAY:this.playDelay)}}
class GameManager{constructor(players){const wallHack=config.WALL_HACK;this.players=players||[new HumanPlayer(0,wallHack),new BotPlayer(1,wallHack),new BotPlayer(2,wallHack),new BotPlayer(3,wallHack),]}
newGame(gameArg=null){let game=gameArg?gameArg:new Game(this.players);globalThis.currentGame={game:game,players:this.players};let gameBoard=document.querySelector('.board');gameBoard.focus();return game}
createFromLocalStorage(){let localStorageGame=JSON.parse(localStorage.getItem("mahjongGame"));if(localStorageGame){var rules=localStorageGame.game.rules;if("faan_laak_table" in rules){Ruleset.register(Cantonese);rules=new Cantonese()}else{Ruleset.register(ChineseClassical);rules=new ChineseClassical()}
var gameObj=localStorageGame.game;this.players=[new HumanPlayer(0,!1,!1),new BotPlayer(1),new BotPlayer(2),new BotPlayer(3),];gameObj.rules=rules;gameObj.wall=new Wall(this.players,localStorageGame.game.wall);var game=new Game(this.players,gameObj);var lsPlayers=localStorageGame.game.players;var publiclyVisible=[];var discardsBackup=JSON.parse(JSON.stringify(gameObj.discards));for(var i=0;i<4;i++){this.players[i].game=game;this.players[i].chicken=lsPlayers[i].chicken;this.players[i].discards=lsPlayers[i].discards;this.players[i].draws=lsPlayers[i].draws;this.players[i].el=document.getElementById(i);this.players[i].has_won=lsPlayers[i].has_won;this.players[i].lastClaim=lsPlayers[i].lastClaim;this.players[i].latest=lsPlayers[i].latest;var tileTracker=new TileTracker(i,lsPlayers[i].tracker.tiles);var ui=i===0?new ClientUI(this.players[i],tileTracker):!1;tileTracker.setUI(ui);if(ui)tileTracker.ui.resetTracker(tileTracker.tiles);this.players[i].tracker=tileTracker;this.players[i].ui=ui;for(var j=0;j<lsPlayers[i].locked.length;j++){var tiles=lsPlayers[i].locked[j].map(t=>new GameTile(null,t.values));this.players[i].lockClaim(tiles);lsPlayers[i].locked[j].forEach(t=>publiclyVisible.push(t.values.tile))}
this.players[i].personality=new Personality(this.players[i],lsPlayers[i].personality);this.players[i].robbed=lsPlayers[i].robbed;this.players[i].rules=rules;this.players[i].selfdraw=lsPlayers[i].selfdraw;for(var j=0;j<lsPlayers[i].tiles.length;j++){this.players[i].append(new GameTile(null,lsPlayers[i].tiles[j].values))}
this.players[i].tilesDead=lsPlayers[i].tilesDead;this.players[i].tilesLeft=lsPlayers[i].tilesLeft;this.players[i].waiting=lsPlayers[i].waiting;this.players[i].wincount=lsPlayers[i].wincount;this.players[i].wind=lsPlayers[i].wind;this.players[i].windOfTheRound=lsPlayers[i].windOfTheRound;this.players[i]._score=lsPlayers[i]._score;this.players[i].el.setAttribute("data-wincount",this.players[i].wincount);this.players[i].el.setAttribute("data-score",Game.getPaddedDataScore(this.players[i]._score));if(ui){ui.markTilesLeft(gameObj.wall.remaining);for(var j=0;j<lsPlayers[i].bonus.length;j++){var tile=new GameTile(lsPlayers[i].bonus[j]);tile.bonus(j+1);this.players[i].append(tile);publiclyVisible.push(lsPlayers[i].bonus[j])}
for(var j=0;j<this.players[i].tiles.length;j++){ui.append(this.players[i].tiles[j])}}else{var el=this.players[i].el;for(var j=0;j<lsPlayers[i].bonus.length;j++){var tile=new GameTile(lsPlayers[i].bonus[j]);tile.bonus(j+1);el.appendChild(tile);publiclyVisible.push(lsPlayers[i].bonus[j])}
for(var j=0;j<this.players[i].locked.length;j++){var sortedLocked=JSON.parse(JSON.stringify(this.players[i].locked[j])).sort((a,b)=>a.values.tile-b.values.tile);for(var k=0;k<sortedLocked.length;k++){var tile=new GameTile(null,sortedLocked[k].values);tile.lock(j+1);el.appendChild(tile)}}
for(var j=0;j<this.players[i].tiles.length;j++){el.appendChild(create(-1))}}
this.players[i].bonus=lsPlayers[i].bonus}
if(game.discard)game.discard=new GameTile(null,game.discard.values);game.discards=discardsBackup;for(var i=0;i<game.discards.length;i++){let tile=game.discards[i].values.tile;let discard=create(tile);discard.mark(`discard`);document.querySelector(`.discards`).appendChild(discard);publiclyVisible.push(tile)}
for(var i=0;i<4;i++){publiclyVisible.forEach(t=>this.players[i].tracker.seen(t))}
rotateWinds(rules,game.wind,game.windOfTheRound,game.hand,game.draws);if(document.querySelector(".countdown-bar")==null){var bar=document.createElement(`div`);bar.classList.add(`countdown-bar`,"active");document.querySelector(`.discards`).prepend(bar);this.players[0].ui.bar=bar}
return this.newGame(game)}else return this.newGame()}}(function(){var existingGame=localStorage.getItem("mahjongGame");if(existingGame)promptResume();else if(config.PLAY_IMMEDIATELY)play();else offerChoice();function promptResume(){if(!noSleep.enabled)noSleep.enable();modal.choiceInput("Resume previous game?",[{label:`Sure`,value:`yes`},{label:`No, take me to main menu`,value:`no`},],result=>{if(result===`yes`)play(!0);else offerChoice()})}
function play(resume=!1){if(!noSleep.enabled)noSleep.enable();let manager=new GameManager();let game=resume?manager.createFromLocalStorage():manager.newGame();game.startGame(()=>{document.body.classList.add("finished");let gameui=game.players.find((p)=>p.ui).ui;config.flushLog();return modal.showFinalScores(gameui,game.rules,game.scoreHistory,()=>{document.body.classList.remove("finished");rotateWinds.reset();offerChoice()})},resume)}
function offerChoice(){if(!noSleep.enabled)noSleep.enable();const options=[{description:"There are currently two modes of play on offer:"},{label:"I'd like to play some mahjong!",value:"play"},{label:"I just want to watch the bots play",value:"watch"},{description:"Alternatively, you can modify the game settings:",align:"center",},{label:"Change settings",value:"settings",back:!0},{description:"(you can also open the settings during play)",align:"center",},];options.fixed=!0;modal.choiceInput("Welcome! What would you like to do?",options,(result)=>{config.BOT_PLAY=result==="watch";if(result==="watch")config.FORCE_OPEN_BOT_PLAY=!0;if(result==="settings")return modal.pickPlaySettings();if(result==="theming")return modal.pickTheming();play()})}})();for(var i=0;i<4;i++){document.getElementById(i).setAttribute("data-score",Game.getPaddedDataScore(""))}})()